<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Drone Embedded Operating System</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hardware.html"><strong aria-hidden="true">1.1.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="bmp-from-bluepill.html"><strong aria-hidden="true">1.2.</strong> BMP from a Blue Pill</a></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">1.3.</strong> Hello, world!</a></li></ol></li><li class="chapter-item expanded "><a href="bluepill-blink.html"><strong aria-hidden="true">2.</strong> Blink an LED</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bluepill-blink/full-speed.html"><strong aria-hidden="true">2.1.</strong> Run at Full Speed</a></li><li class="chapter-item expanded "><a href="bluepill-blink/sys-tick.html"><strong aria-hidden="true">2.2.</strong> Work with a Timer</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">3.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fibers.html"><strong aria-hidden="true">3.1.</strong> Fibers</a></li><li class="chapter-item expanded "><a href="processes.html"><strong aria-hidden="true">3.2.</strong> Processes</a></li><li class="chapter-item expanded "><a href="threads.html"><strong aria-hidden="true">3.3.</strong> Threads</a></li><li class="chapter-item expanded "><a href="tasks.html"><strong aria-hidden="true">3.4.</strong> Tasks</a></li><li class="chapter-item expanded "><a href="message-passing.html"><strong aria-hidden="true">3.5.</strong> Message-Passing</a></li></ol></li><li class="chapter-item expanded "><a href="heap.html"><strong aria-hidden="true">4.</strong> Dynamic Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="heaptrace.html"><strong aria-hidden="true">4.1.</strong> Heap Tracing</a></li></ol></li><li class="chapter-item expanded "><a href="reg.html"><strong aria-hidden="true">5.</strong> Memory-Mapped Registers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reg/api.html"><strong aria-hidden="true">5.1.</strong> API Summary</a></li><li class="chapter-item expanded "><a href="reg/tag.html"><strong aria-hidden="true">5.2.</strong> Tags</a></li><li class="chapter-item expanded "><a href="periph.html"><strong aria-hidden="true">5.3.</strong> Peripheral Mappings</a></li></ol></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="extensibility.html"><strong aria-hidden="true">7.</strong> Extensibility</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extensibility/cli.html"><strong aria-hidden="true">7.1.</strong> Drone CLI</a></li><li class="chapter-item expanded "><a href="extensibility/platform.html"><strong aria-hidden="true">7.2.</strong> Platform-Specific Layer</a></li><li class="chapter-item expanded "><a href="extensibility/vendor.html"><strong aria-hidden="true">7.3.</strong> Vendor-Specific Layer</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Drone Embedded Operating System</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Drone is an Embedded Operating System for writing real-time applications in
Rust. It aims to bring modern development approaches without compromising
performance into the world of embedded programming.</p>
<h2 id="supported-hardware"><a class="header" href="#supported-hardware">Supported hardware</a></h2>
<p>As of today, Drone can run on ARMv7-M, ARMv8-M, and RISC-V architectures. It is
tested on Cortex®-M3, Cortex®-M4, Cortex®-M33, Nuclei Bumblebee cores, and
STM32, NRF52, NRF91, GD32VF103 MCU series.</p>
<p>Other hardware support is likely to be added in the future. One restriction for
adding a new architecture is that it must implement atomic CAS
(compare-and-swap) operations, as Drone highly relies on good atomics support
from hardware.</p>
<p>As of debug probes, Drone utilities provide native support for
<a href="https://www.segger.com/products/debug-probes/j-link/">J-Link</a> and <a href="http://black-magic.org/">Black Magic
Probe</a>, as well as generic interface to
<a href="http://openocd.org/">OpenOCD</a>.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h2>
<ul>
<li>
<p><em>Energy effective from the start</em>. Drone encourages interrupt-driven execution
model.</p>
</li>
<li>
<p><em>Hard Real-Time</em>. Drone relies on atomic operations instead of using critical
sections.</p>
</li>
<li>
<p><em>Fully preemptive multi-tasking with strict priorities</em>. A higher priority
task takes precedence with minimal latency.</p>
</li>
<li>
<p><em>Highly concurrent.</em> Multi-tasking in Drone is very cheap, and Rust ensures it
is also safe.</p>
</li>
<li>
<p><em>Message passing concurrency</em>. Drone ships with synchronization primitives out
of the box.</p>
</li>
<li>
<p><em>Single stack by default</em>. Drone concurrency primitives are essentially
stack-less state machines. But <em>stackful tasks are still supported</em>.</p>
</li>
<li>
<p><em>Dynamic memory enabled</em>. Drone lets you use convenient data structures like
mutable strings or vectors while still staying deterministic and code
efficient.</p>
</li>
</ul>
<h2 id="why-use-drone"><a class="header" href="#why-use-drone">Why use Drone?</a></h2>
<ul>
<li>
<p>Async/await by default. Drone provides all required run-time to use native
async/await syntax and execute <code>Future</code>s.</p>
</li>
<li>
<p>Doesn't require <code>unsafe</code> code. In spite of the fact that Drone core inevitably
relies on <code>unsafe</code> code, Drone applications can fully rely on the safe
abstractions provided by Drone.</p>
</li>
<li>
<p>Modern tooling. Apart from standard Rust tools like <code>cargo</code> package manager,
<code>rustfmt</code> code formatter, <code>clippy</code> code linter, Drone provides <code>drone</code>
command-line utility which can generate a new Drone project for your hardware,
or manage your debug probe.</p>
</li>
<li>
<p>Primary stack is stack-overflow protected regardless of MMU/MPU presence. But
secondary stackful tasks require MMU/MPU to ensure the safety.</p>
</li>
<li>
<p>Debug communication channels. Rust's <code>print!</code>, <code>eprint!</code> and similar macros
are mapped to Cortex-M's SWO channels 0 and 1 out of the box. Debug messages
incur no overhead when no debug probe is connected.</p>
</li>
<li>
<p><code>Drone.toml</code> configuration file, which saves you from manually writing linker
scripts.</p>
</li>
<li>
<p>Rich and safe zero-cost abstractions for memory-mapped registers. Drone
automatically generates register bindings from vendor-provided SVD files. It
also provides a way to write code generic over similar peripherals.</p>
</li>
</ul>
<h2 id="what-drone-doesnt"><a class="header" href="#what-drone-doesnt">What Drone doesn't</a></h2>
<ul>
<li>
<p>Drone doesn't support loading dynamic applications. It is a library OS and is
linked statically with its application.</p>
</li>
<li>
<p>Drone doesn't implement time-slicing. It has a different execution model, but
optional time-slicing may be added in the future.</p>
</li>
</ul>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Unlike many other programming fields, software development for embedded systems
requires special hardware. Bare minimum is a target device, for which the
software is developed, and a debug probe that is responsible for programming and
debugging the device. Often for a particular microcontroller unit (MCU), the
vendor offers a development board, which incorporates an MCU, a debug probe,
and some peripherals. But when the development reaches a printed circuit board
(PCB) prototyping stage, an external probe is desirable. There are various
debug probes in the market. A Chinese clone can cost a couple of dollars, while
original probes often cost hundreds. But there is one unique option that is
supported by Drone out-of-the-box - <a href="http://black-magic.org/">Black Magic Probe</a>.</p>
<p>Black Magic Probe, or BMP, is an open-source tool, like Rust or Drone, which is
invaluable when it comes to troubleshooting. Currently it supports Cortex-M and
Cortex-A targets. BMP implements the GDB protocol directly, which is nice,
because there is no need for intermediate software like OpenOCD. Also it embeds
a USB-to-UART converter. The official hardware is sold around $60 and is quite
good. But the firmware supports other hardware options. The most affordable of
which is the <a href="https://web.archive.org/web/20190524151648/wiki.stm32duino.com/index.php?title=Blue_Pill">Blue
Pill</a>.</p>
<p>Blue Pill is an ultra-popular and cheap development board for STM32F103C8T6
microcontroller. It can be bought for around $1.50 from AliExpress and also can
be programmed with Drone. It has 32-bit Cortex-M3 core running at 72 Mhz max, 20
Kb of RAM, and <a href="https://web.archive.org/web/20190524151648/wiki.stm32duino.com/index.php?title=Blue_Pill#128_KB_flash_on_C8_version">128
Kb</a>
of flash memory. This is good for many applications and is enough to get started
with Drone. So the most affordable start would be with two Blue Pill boards, one
as a debug probe and the other as the host for Drone projects.</p>
<p>But there is another tool needed to flash the BMP firmware to a Blue Pill - a
USB-to-UART adapter. Out of the box a Blue Pill is flashed with a factory boot
loader, which allows programming its flash memory through UART. The cheapest
adapter would be enough for this. CH340G can be bought for around $0.50 from
AliExpress. It will not be needed after initial bootstrap of BMP, because it has
its own USB-to-UART. Though it is convenient to have a spare adapter, as
sometimes there can be multiple UARTs involved.</p>
<h1 id="hardware"><a class="header" href="#hardware">Hardware</a></h1>
<p>To make a start with Drone the most affordable, the following reference hardware
was selected for this book:</p>
<p><img src="./assets/packed.jpg" alt="Packed" /></p>
<ul>
<li>2× STM32F103C8T6 development boards (Blue Pills)</li>
<li>CH340G USB-TTL converter</li>
<li>Female-to-female jumper wires</li>
</ul>
<p>And optionally:</p>
<ul>
<li>2× Angled 40-pins 2.54 mm header - Blue Pills already come with straight pin headers</li>
</ul>
<p><img src="./assets/unpacked.jpg" alt="Unpacked" /></p>
<p>Usually Blue Pills come with not soldered pin-headers, except the SWD header. If
you don't want to solder, you can twist the wires like this:</p>
<p><img src="./assets/twisted.jpg" alt="Twisted joints" /></p>
<p>Please be aware that the above method can lead to signal integrity issues or
shorts. Therefore proper soldering is recommended. Here are the Blue Pills
soldered with the angled pin-headers:</p>
<p><img src="./assets/soldered.jpg" alt="Soldered pin-headers" /></p>
<p>In the next chapter we will show how to convert one of the Blue Pills to a Black
Magic Proble.</p>
<h1 id="black-magic-probe-from-a-blue-pill"><a class="header" href="#black-magic-probe-from-a-blue-pill">Black Magic Probe from a Blue Pill</a></h1>
<p>This chapter describes the process of making a Black Magic Probe from a Blue
Pill board. The steps were tested on Ubuntu 18.04.3 LTS and Arch Linux 5.3.7.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<p>The process requires the following packages to be installed:</p>
<pre><code class="language-shell">$ sudo apt install build-essential \
                   curl \
                   dfu-util \
                   gcc-arm-none-eabi \
                   gdb-multiarch \
                   git \
                   python \
                   python-pip
</code></pre>
<p>or on Arch Linux:</p>
<pre><code>$ sudo pacman -S curl \
                 dfu-util \
                 git \
                 python \
                 python-pip
$ yaourt -S arm-none-eabi-gcc \
            gdb-multiarch
</code></pre>
<p>It is convenient to join the <code>dialout</code> group. This way you will not need
super-user privileges to work with BMP and USB-to-UART adapter:</p>
<pre><code class="language-shell">$ sudo adduser $(id -un) dialout
</code></pre>
<p>or the <code>uucp</code> group on Arch Linux:</p>
<pre><code class="language-shell">$ sudo gpasswd -a $(id -un) uucp
</code></pre>
<p>In order for the group change to take effect, you will need to re-login.</p>
<p>Get the stm32loader script and install its python dependencies:</p>
<pre><code class="language-shell">$ git clone https://github.com/jsnyder/stm32loader
$ pip install pyserial
</code></pre>
<p>Get the BMP firmware:</p>
<pre><code class="language-shell">$ git clone https://github.com/blacksphere/blackmagic
$ cd blackmagic
$ git submodule update --init --recursive
</code></pre>
<p>BMP repository provides udev rules for the probe. The rules instruct udev to
symlink the GDB endpoint to <code>/dev/ttyBmpGdb</code> and the UART to
<code>/dev/ttyBmpTarg</code>. Also they allow to upgrade BMP firmware without super-user
permissions.</p>
<pre><code class="language-shell">$ sudo cp driver/99-blackmagic.rules /etc/udev/rules.d/
$ sudo udevadm control --reload-rules
</code></pre>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>Correct probe host should be selected. In our case it's <code>swlink</code>.</p>
<pre><code class="language-shell">$ make PROBE_HOST=swlink
</code></pre>
<p><img src="./assets/blackmagic-make.png" alt="Building" /></p>
<p>This will produce two binaries we are interested in: <code>src/blackmagic_dfu.bin</code>
and <code>src/blackmagic.bin</code>. The first is a bootloader, which will be flashed with
the USB-to-UART adapter. And the second is the actual firmware, which will be
loaded through USB with help of the bootloader.</p>
<h2 id="flashing-bootloader"><a class="header" href="#flashing-bootloader">Flashing Bootloader</a></h2>
<ol>
<li>
<p>Connect the USB-to-UART adapter with the Blue Pill according to this table:</p>
<table><thead><tr><th>USB-to-UART</th><th>Blue Pill</th></tr></thead><tbody>
<tr><td>GND</td><td>GND</td></tr>
<tr><td>RXD</td><td>A9</td></tr>
<tr><td>TXD</td><td>A10</td></tr>
</tbody></table>
<p><strong>Warning:</strong> Don't connect any power source now. We will power up the board
through USB at the step 5. Using USB together with 5V or 3.3 pins can damage
your board.</p>
</li>
<li>
<p>Set the jumper on the USB-to-UART adapter to the position where VCC and 3V3
are shorted. This will set the adapter's output voltage to 3.3 v. Although it
is not strictly needed, because A9 and A10 pins are five-volt-tolerant.</p>
</li>
<li>
<p>Set BOOT0 jumper on the Blue Pill to 1 to boot into the factory programmed
bootloader. The bootloader is responsible for programming the board through
UART.</p>
</li>
</ol>
<p><img src="./assets/bluepill-ch340g.jpg" alt="CH340G connected to Blue Pill" /></p>
<ol start="4">
<li>
<p>Before connecting the USB-to-UART adapter to your PC, open the system
journal:</p>
<pre><code class="language-shell">$ journalctl -f
</code></pre>
<p>Connect the USB-to-UART adapter and notice the name it is assigned:</p>
</li>
</ol>
<p><img src="./assets/ch340g-journal.png" alt="CH340G in journal" /></p>
<ol start="5">
<li>
<p>Connect a USB-cable to the Blue Pill and start the flashing process. Replace
<code>/dev/ttyUSB0</code> with your value from the previous step. If the process is not
starting, press the reset button on the Blue Pill.</p>
<pre><code class="language-shell">$ ../stm32loader/stm32loader.py -p /dev/ttyUSB0 -e -w -v src/blackmagic_dfu.bin
</code></pre>
</li>
</ol>
<p><img src="./assets/stm32loader.png" alt="Successful load" /></p>
<ol start="6">
<li>Set BOOT0 jumper on the Blue Pill back to 0.</li>
</ol>
<p><img src="./assets/bluepill-jumpers.jpg" alt="Reset Blue Pill jumpers" /></p>
<h2 id="flashing-firmware"><a class="header" href="#flashing-firmware">Flashing Firmware</a></h2>
<p>Now you can disconnect the USB-to-UART adapter from the Blue Pill and your
PC. The firmware will be flashed through USB port:</p>
<pre><code class="language-shell">$ dfu-util -d 1d50:6018,:6017 -s 0x08002000:leave -D src/blackmagic.bin
</code></pre>
<p><img src="./assets/dfu-util.png" alt="Successful load" /></p>
<p>Now we will check that it works. Reconnect the Blue Pill and open a GDB session:</p>
<pre><code class="language-shell">$ gdb-multiarch
</code></pre>
<p>At the GDB prompt enter the following commands:</p>
<pre><code class="language-text">target extended-remote /dev/ttyBmpGdb
monitor version
</code></pre>
<p><img src="./assets/gdb-monitor-version.png" alt="GDB check" /></p>
<p>If your output is similar to the output above, congratulations! Now your Blue
Pill is a Black Magic Probe! Next time you need to upgrade the firmware you only
need to repeat the <code>dfu-util</code> command above.</p>
<h2 id="wiring"><a class="header" href="#wiring">Wiring</a></h2>
<p>Here is a general pin-out description and an example connection with a Blue
Pill:</p>
<table><thead><tr><th>Black Magic Probe</th><th>Function</th><th>Blue Pill Target</th></tr></thead><tbody>
<tr><td>GND</td><td>GND</td><td>GND</td></tr>
<tr><td>SWCLK</td><td>JTCK/SWCLK</td><td>SWCLK</td></tr>
<tr><td>SWIO</td><td>JTMS/SWDIO</td><td>SWIO</td></tr>
<tr><td>A15</td><td>JTDI</td><td></td></tr>
<tr><td>B3</td><td>JTDO</td><td></td></tr>
<tr><td>B4</td><td>JNTRST</td><td>R</td></tr>
<tr><td>B6</td><td>UART1 TX</td><td></td></tr>
<tr><td>B7</td><td>UART1 RX</td><td>B3</td></tr>
<tr><td>A3</td><td>UART2 RX (TRACESWO)</td><td></td></tr>
</tbody></table>
<p><img src="./assets/bmp-wiring.jpg" alt="BMP wiring" /></p>
<h2 id="comparison-with-official-bmp"><a class="header" href="#comparison-with-official-bmp">Comparison with Official BMP</a></h2>
<p><img src="./assets/official-bmp-comparison.jpg" alt="Blue Pill and Official BMP" /></p>
<p>There are a few advantages of the official BMP:</p>
<ul>
<li>Has a Cortex Debug connector</li>
<li>Can power the target</li>
<li>Can sense the target's voltage</li>
<li>Has more LEDs</li>
<li>Has more robust circuitry</li>
</ul>
<p>These advantages are not critical, however by buying the official hardware you
are supporting the BMP project.</p>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h1>
<p>In the previous chapter we created a debug probe from a Blue Pill, and attached
it to another Blue Pill board. In this chapter we will run our first Drone
program on the microcontroller.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>If you haven't installed Rust yet, follow the instructions from
<a href="https://rustup.rs/">rustup.rs</a>. Drone is currently available only for Nightly
channel of Rust. You need to install it first:</p>
<pre><code class="language-shell">$ rustup toolchain install nightly \
      -c rust-src -c rustfmt -c clippy -c llvm-tools-preview \
      -t thumbv7m-none-eabi
</code></pre>
<p>Not all nightly releases have all components available. The above command will
walk backwards in time to find the most recent release with all needed
components.</p>
<h2 id="just-command"><a class="header" href="#just-command"><code>just</code> command</a></h2>
<p>In embedded development often there are various project-specific tasks that are
needed to run from time to time. Therefore we encourage using an excellent Rust
crate <a href="https://github.com/casey/just"><code>just</code></a>:</p>
<pre><code class="language-shell">$ cargo +stable install just
</code></pre>
<p>Just is a command runner inspired by <code>make</code>. Whenever you see a project with
<code>Justfile</code> at the root, run <code>just --list</code> to see all available
commands. Furthermore <code>drone new</code> command will generate a <code>Justfile</code> for you. It
is advisable to put <code>alias j=&quot;just&quot;</code> to your shell config, so you could just
type <code>j</code> instead of <code>just</code>.</p>
<h2 id="drone-command"><a class="header" href="#drone-command"><code>drone</code> command</a></h2>
<p>The Drone OS project consists of many Rust crates. However there is a single
entry point for it - the <code>drone</code> command-line utility:</p>
<pre><code class="language-shell">$ cargo +nightly install drone
</code></pre>
<p>For now you should have all prerequisites and could follow to the next step -
generating your first Drone crate.</p>
<h2 id="new-project"><a class="header" href="#new-project">New project</a></h2>
<p>Let's tell <code>drone</code> to generate a new Drone crate for us. We have to specify the
target MCU family, which is <code>stm32f103</code> for Blue Pill, the flash memory size,
the RAM size, and the project name.</p>
<pre><code class="language-shell">$ drone new --device stm32f103 --flash-size 128K --ram-size 20K hello-world
$ cd hello-world
</code></pre>
<p>The first thing to do inside the project is to install dependencies:</p>
<pre><code class="language-shell">$ just deps
</code></pre>
<p>You should also run this task after each Rust update.</p>
<p>Now we assume you have the Blue Pills connected as follows (as described in the
previous chapter):</p>
<p><img src="./assets/bmp-wiring.jpg" alt="BMP wiring" /></p>
<p>Let's flash our newly created project to the target Blue Pill. If it has to be
built first, it could take a while:</p>
<pre><code class="language-shell">$ just flash
</code></pre>
<p>A successful result looks like this:</p>
<p><img src="./assets/just-flash.png" alt="Flash success" /></p>
<p>And finally, check the SWO output from the device.</p>
<pre><code class="language-shell">$ just log
</code></pre>
<p><img src="./assets/just-swo.png" alt="SWO output" /></p>
<p>If you see an output like above, congratulations! You have successfully set up
an environment for developing Drone projects.</p>
<h1 id="blink-an-led"><a class="header" href="#blink-an-led">Blink an LED</a></h1>
<p>In this section we will write an application that will raise the system clock
frequency to 72 MHz and blink the on-board LED connected to the PC13 pin. The
application will involve using multiple threads, futures, streams, memory-mapped
registers, and peripherals.</p>
<video autoplay loop muted width="100%">
<source src="./assets/blink.webm" type="video/webm" />
<source src="./assets/blink.mp4" type="video/mp4" />
</video>
<p>The full code for this example can be found at
<a href="https://github.com/drone-os/bluepill-blink">Github</a>.</p>
<h2 id="generate-a-project"><a class="header" href="#generate-a-project">Generate a project</a></h2>
<p>To begin with, let's generate a new Drone project for a Blue Pill board:</p>
<pre><code class="language-shell">$ drone new \
        --toolchain nightly-2020-04-30 \ # we need to pick a fresh nightly with
                                       \ # all required rustup components
        --device stm32f103 \ # microcontroller identifier
        --flash-size 128K \ # flash memory size in bytes
        --ram-size 20K \ # RAM size in bytes
        bluepill-blink # project name
$ cd bluepill-blink
$ just deps
</code></pre>
<p>To briefly test the newly generated application, connect a Black Magic Probe to
your PC, and a Blue Pill board to the BMP as in <a href="./hello-world.html">Hello,
world!</a> chapter. Flash the firmware and check the SWO output:</p>
<pre><code class="language-shell">$ just flash
$ just log
</code></pre>
<p>If you can see a &quot;Hello, world!&quot; message, follow to the next chapter.</p>
<h1 id="run-at-full-speed"><a class="header" href="#run-at-full-speed">Run at Full Speed</a></h1>
<p>According to the datasheet, STM32F103 MCU can run at the maximum frequency of 72
MHz. But by default it runs at only 8 MHz. To achieve the full potential of the
chip, the system frequency should be raised in the run-time.</p>
<p>There are three options for the system clock source:</p>
<ul>
<li>
<p>HSI (High Speed Internal) - an RC oscillator running at constant 8 MHz and
sitting inside the MCU chip. It is the default source for the system clock
selected at the start-up.</p>
</li>
<li>
<p>HSE (High Speed External) - an optional external resonator component in the
range from 4 to 16 MHz. A Blue Pill board has a 8 MHz crystal connected to the
MCU (the component in a metal case right beside the MCU marked as Y2.)</p>
</li>
<li>
<p>PLL (Phase-Locked Loop) - a peripheral inside the MCU that can be used as a
multiplier for HSI or HSE. The maximum multiplier for HSI is 8, which can give
us 64 MHz, and for HSE - 16, which can theoretically result in 128 MHz, but
the output frequency of PLL shouldn't exceed 72 MHz.</p>
</li>
</ul>
<p>Given the above, in order to achieve 72 MHz, we should take the following steps:</p>
<ol>
<li>Start the HSE oscillator and wait for it to stabilize.</li>
<li>Start the PLL with the HSE input and the multiplier of 9. Wait for it to
stabilize.</li>
<li>Select the PLL as the source for the system clock.</li>
</ol>
<p>For a start, let's create a module for our project-level constants. Create a new
file at <code>src/consts.rs</code> with the following content:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Project constants.

/// HSE crystal frequency.
pub const HSE_FREQ: u32 = 8_000_000;

/// PLL multiplication factor.
pub const PLL_MULT: u32 = 9;

/// System clock frequency.
pub const SYS_CLK: u32 = HSE_FREQ * PLL_MULT;
<span class="boring">}
</span></code></pre></pre>
<p>And register the module in the <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod consts;
<span class="boring">}
</span></code></pre></pre>
<p>When the application will need to wait for HSE and PLL clocks stabilization, we
don't want it to be constantly checking the flags wasting CPU cycles and energy,
but rather to subscribe for an interrupt and sleep until it is triggered. We
will use the RCC interrupt for this purpose:</p>
<p><img src="bluepill-blink/../assets/vtable-rcc.png" alt="Vector Table" /></p>
<p>From the table above, which can be found in the Reference Manual, we only need
the position of the RCC interrupt. Let's put this interrupt to the application
Vector Table. For this you need to edit <code>thr::nvic!</code> macro in <code>src/thr.rs</code>. By
default it looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thr::nvic! {
    // ... The header is skipped ...

    threads =&gt; {
        exceptions =&gt; {
            /// All classes of faults.
            pub hard_fault;
        };
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>There is only a HardFault handler defined. Note that according the above table,
HardFault doesn't have a position number, therefore it is referred only by its
name. We need to add a new interrupt handler at the position of 5:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thr::nvic! {
    // ... The header is skipped ...

    threads =&gt; {
        exceptions =&gt; {
            /// All classes of faults.
            pub hard_fault;
        };
        interrupts =&gt; {
            /// RCC global interrupt.
            5: pub rcc;
        };
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>Since the new handler has a numeric position, the name can be arbitrary.</p>
<p>Let's open the root task handler at <code>src/tasks/root.rs</code>. By default it looks
like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! The root task.

use crate::{thr, thr::ThrsInit, Regs};
use drone_cortexm::{reg::prelude::*, thr::prelude::*};

/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let thr = thr::init(thr_init);

    thr.hard_fault.add_once(|| panic!(&quot;Hard Fault&quot;));

    println!(&quot;Hello, world!&quot;);

    // Enter a sleep state on ISR exit.
    reg.scb_scr.sleeponexit.set_bit();
}
<span class="boring">}
</span></code></pre></pre>
<p>In Drone OS the very first task with the lowest priority named root. Its
function handler is called by the program entry point at
<code>src/bin/bluepill-blink.rs</code>, after finishing unsafe initialization routines. The
root handler receives two arguments of types <code>Regs</code> and <code>ThrsInit</code>. Both are
zero-sized types implementing <code>Token</code> trait, which permits existence of only one
instance at a time. Instantiating a <code>Token</code> type is unsafe, that is why it is
done inside the unsafe entry point at <code>src/bin/bluepill-blink.rs</code>.</p>
<p>The <code>reg</code> argument is a set of tokens for all available memory-mapped
registers. It is supposed to be destructured into individual register tokens or
register field tokens within the root handler.</p>
<p>The second <code>thr_init</code> argument's purpose is to pass it to <code>thr::init</code>
function. The function runs an initialization routine for threading system and
returns an instance of <code>Thrs</code> type. <code>Thrs</code> is also a zero-sized type similar to
<code>Regs</code>, but for thread tokens.</p>
<p>The root handler adds a one-shot fiber to the HardFault thread. The fiber body
is just a call to the <code>panic!</code> macro. Drone handles panics by writing the panic
message to the log output at port #1, issuing a self-reset request, and blocking
until it's executed.</p>
<p>Let's add a new <code>async</code> function that will be responsible for raising the system
clock frequency to 72 MHz. It will need some registers from RCC and FLASH
peripherals, as well as the RCC thread token.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! The root task.

use crate::{
    consts::{PLL_MULT, SYS_CLK},
    thr,
    thr::ThrsInit,
    Regs,
};
use drone_core::log;
use drone_cortexm::{fib, reg::prelude::*, swo, thr::prelude::*};
use drone_stm32_map::reg;

/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let thr = thr::init(thr_init);

    thr.hard_fault.add_once(|| panic!(&quot;Hard Fault&quot;));

    raise_system_frequency(
        reg.flash_acr,
        reg.rcc_cfgr,
        reg.rcc_cir,
        reg.rcc_cr,
        thr.rcc,
    )
    .root_wait();

    println!(&quot;Hello, world!&quot;);

    // Enter a sleep state on ISR exit.
    reg.scb_scr.sleeponexit.set_bit();
}

async fn raise_system_frequency(
    flash_acr: reg::flash::Acr&lt;Srt&gt;,
    rcc_cfgr: reg::rcc::Cfgr&lt;Srt&gt;,
    rcc_cir: reg::rcc::Cir&lt;Srt&gt;,
    rcc_cr: reg::rcc::Cr&lt;Srt&gt;,
    thr_rcc: thr::Rcc,
) {
    // TODO raise the frequency to 72 MHz
}
<span class="boring">}
</span></code></pre></pre>
<p>An <code>async</code> function is a syntax sugar for a function returning a custom type
implementing <code>Future</code> trait. We execute the returned future using the
<code>.root_wait()</code> method. The <code>root_wait</code> method is supposed to be used inside a
thread with the lowest priority, e.g. in the root task context. Otherwise the
threads that are currently preempted may be stalled. Another option for
executing futures is to use <code>exec</code> or <code>add_exec</code> methods on thread tokens.</p>
<p>It's good to check that the program still works:</p>
<pre><code class="language-shell">$ just flash
$ just log
</code></pre>
<p>Let's start filling out the <code>raise_system_frequency</code> function. First, we need to
enable the RCC interrupt in NVIC (Nested Vectored Interrupt Controller), and
allow the RCC peripheral to trigger the interrupt when HSE or PLL is stabilized:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    thr_rcc.enable_int();
    rcc_cir.modify(|r| r.set_hserdyie().set_pllrdyie());
<span class="boring">}
</span></code></pre></pre>
<p>Then we're enabling the HSE clock and waiting until it's stabilized:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // We need to move ownership of `hserdyc` and `hserdyf` into the fiber.
    let reg::rcc::Cir {
        hserdyc, hserdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_HSERDYF is asserted.
    let hserdy = thr_rcc.add_future(fib::new_fn(move || {
        if hserdyf.read_bit() {
            hserdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    // Enable the HSE clock.
    rcc_cr.modify(|r| r.set_hseon());
    // Sleep until RCC_CIR_HSERDYF is asserted.
    hserdy.await;
<span class="boring">}
</span></code></pre></pre>
<p>And similarly enable the PLL:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // We need to move ownership of `pllrdyc` and `pllrdyf` into the fiber.
    let reg::rcc::Cir {
        pllrdyc, pllrdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_PLLRDYF is asserted.
    let pllrdy = thr_rcc.add_future(fib::new_fn(move || {
        if pllrdyf.read_bit() {
            pllrdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    rcc_cfgr.modify(|r| {
        r.set_pllsrc() // HSE oscillator clock selected as PLL input clock
            .write_pllmul(PLL_MULT - 2) // output frequency = input clock × PLL_MULT
    });
    // Enable the PLL.
    rcc_cr.modify(|r| r.set_pllon());
    // Sleep until RCC_CIR_PLLRDYF is asserted.
    pllrdy.await;
<span class="boring">}
</span></code></pre></pre>
<p>The flash memory settings should be tweaked because of increased frequency:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Two wait states, if 48 MHz &lt; SYS_CLK &lt;= 72 Mhz.
    flash_acr.modify(|r| r.write_latency(2));
<span class="boring">}
</span></code></pre></pre>
<p>Before increasing the frequency, we should wait until the currently ongoing SWO
transmission is finished if any. And also update the SWO prescaler to maintain
the fixed baud-rate defined at the project's <code>Drone.toml</code>. Note that if a debug
probe is not connected, this will be a no-op, thus it's safe to keep this in the
release binary.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    swo::flush();
    swo::update_prescaler(SYS_CLK / log::baud_rate!() - 1);
<span class="boring">}
</span></code></pre></pre>
<p>And finally switch the source for the system clock to PLL:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    rcc_cfgr.modify(|r| r.write_sw(0b10)); // PLL selected as system clock
<span class="boring">}
</span></code></pre></pre>
<p>Here is the final listing of the <code>raise_system_frequency</code> function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn raise_system_frequency(
    flash_acr: reg::flash::Acr&lt;Srt&gt;,
    rcc_cfgr: reg::rcc::Cfgr&lt;Srt&gt;,
    rcc_cir: reg::rcc::Cir&lt;Srt&gt;,
    rcc_cr: reg::rcc::Cr&lt;Srt&gt;,
    thr_rcc: thr::Rcc,
) {
    thr_rcc.enable_int();
    rcc_cir.modify(|r| r.set_hserdyie().set_pllrdyie());

    // We need to move ownership of `hserdyc` and `hserdyf` into the fiber.
    let reg::rcc::Cir {
        hserdyc, hserdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_HSERDYF is asserted.
    let hserdy = thr_rcc.add_future(fib::new_fn(move || {
        if hserdyf.read_bit() {
            hserdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    // Enable the HSE clock.
    rcc_cr.modify(|r| r.set_hseon());
    // Sleep until RCC_CIR_HSERDYF is asserted.
    hserdy.await;

    // We need to move ownership of `pllrdyc` and `pllrdyf` into the fiber.
    let reg::rcc::Cir {
        pllrdyc, pllrdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_PLLRDYF is asserted.
    let pllrdy = thr_rcc.add_future(fib::new_fn(move || {
        if pllrdyf.read_bit() {
            pllrdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    rcc_cfgr.modify(|r| {
        r.set_pllsrc() // HSE oscillator clock selected as PLL input clock
            .write_pllmul(PLL_MULT - 2) // output frequency = input clock × PLL_MULT
    });
    // Enable the PLL.
    rcc_cr.modify(|r| r.set_pllon());
    // Sleep until RCC_CIR_PLLRDYF is asserted.
    pllrdy.await;

    // Two wait states, if 48 MHz &lt; SYS_CLK &lt;= 72 Mhz.
    flash_acr.modify(|r| r.write_latency(2));

    swo::flush();
    swo::update_prescaler(SYS_CLK / log::baud_rate!() - 1);

    rcc_cfgr.modify(|r| r.write_sw(0b10)); // PLL selected as system clock
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="work-with-a-timer"><a class="header" href="#work-with-a-timer">Work with a Timer</a></h1>
<p>In this chapter we will work with a timer peripheral to timely assert and
de-assert the PC13 pin, which is connected to the green LED on the Blue Pill
board. The STM32F103 MCU possesses 7 timers of 4 different kinds. We will use
the SysTick timer, which is present in all Cortex-M MCUs.</p>
<p>Drone already has a universal interface for timer peripherals in a form of
<code>drone_cortexm::drv::timer::Timer</code> trait, as well as the SysTick driver
implementation at <code>drone_cortexm::drv::sys_tick::SysTick</code>. However in this
walk-through we will use interrupts and memory-mapped registers directly.</p>
<p>Firstly, we need to allocate an interrupt used by the timer peripheral. Let's
refer to the Reference Manual:</p>
<p><img src="bluepill-blink/../assets/vtable-sys-tick.png" alt="Vector Table" /></p>
<p>Unlike the RCC interrupt from the previous chapter, the SysTick doesn't have a
position value. This means that we need to declare it using a precise name and
before all the positional interrupts:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thr::nvic! {
    // ... The header is skipped ...

    threads =&gt; {
        exceptions =&gt; {
            /// All classes of faults.
            pub hard_fault;
            /// System tick timer.
            pub sys_tick;
        };
        interrupts =&gt; {
            /// RCC global interrupt.
            5: pub rcc;
        };
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>According to the Reference Manual, the frequency of the SysTick clock is the
system clock divided by 8. Let's add this to our constants module
<code>src/consts.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// SysTick clock frequency.
pub const SYS_TICK_FREQ: u32 = SYS_CLK / 8;
<span class="boring">}
</span></code></pre></pre>
<p>Let's update our root handler:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! The root task.

use crate::{
    consts::{PLL_MULT, SYS_CLK, SYS_TICK_FREQ},
    thr,
    thr::ThrsInit,
    Regs,
};
use drone_core::log;
use drone_cortexm::{fib, reg::prelude::*, swo, thr::prelude::*};
use drone_stm32_map::{
    periph::{
        gpio::{periph_gpio_c, GpioC, GpioPortPeriph},
        sys_tick::{periph_sys_tick, SysTickPeriph},
    },
    reg,
};
use futures::prelude::*;

/// An error returned when a receiver has missed too many ticks.
#[derive(Debug)]
pub struct TickOverflow;

/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let thr = thr::init(thr_init);
    let gpio_c = periph_gpio_c!(reg);
    let sys_tick = periph_sys_tick!(reg);

    thr.hard_fault.add_once(|| panic!(&quot;Hard Fault&quot;));

    raise_system_frequency(
        reg.flash_acr,
        reg.rcc_cfgr,
        reg.rcc_cir,
        reg.rcc_cr,
        thr.rcc,
    )
    .root_wait();

    beacon(gpio_c, sys_tick, thr.sys_tick)
        .root_wait()
        .expect(&quot;beacon fail&quot;);

    // Enter a sleep state on ISR exit.
    reg.scb_scr.sleeponexit.set_bit();
}

// We leave this function unchanged.
async fn raise_system_frequency(...) {...}

async fn beacon(
    gpio_c: GpioPortPeriph&lt;GpioC&gt;,
    sys_tick: SysTickPeriph,
    thr_sys_tick: thr::SysTick,
) -&gt; Result&lt;(), TickOverflow&gt; {
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We added an error type <code>TickOverflow</code>, which we discuss later:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct TickOverflow;
<span class="boring">}
</span></code></pre></pre>
<p>At the beginning of the root handler we added calls to two <code>periph_*!</code>
macros. These macros take parts of <code>reg</code> structure and move them into separate
<code>gpio_c</code> and <code>sys_tick</code> structures. The macros do nothing at the run-time,
because <code>reg</code>, <code>gpio_c</code>, and <code>sys_tick</code> are zero sized types, but they inform
the type system of moved ownership.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let gpio_c = periph_gpio_c!(reg);
    let sys_tick = periph_sys_tick!(reg);
<span class="boring">}
</span></code></pre></pre>
<p>Those structures hold all registers associated with the corresponding
peripherals. We pass those peripheral structures to a new <code>async</code> function named
<code>beacon</code>. This time the function returns a <code>Result</code> type, and we handle it with
a panic:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    beacon(gpio_c, sys_tick, thr.sys_tick)
        .root_wait()
        .expect(&quot;beacon fail&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Let's start filling out the <code>beacon</code> function. We configure the SysTick timer
peripheral to trigger the SysTick interrupt each second:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Attach a listener that will notify us on each interrupt trigger.
    let mut tick_stream = thr_sys_tick.add_pulse_try_stream(
        // This closure will be called when a receiver no longer can store the
        // number of ticks since the last stream poll. If this happens, a
        // `TickOverflow` error will be sent over the stream as is final value.
        || Err(TickOverflow),
        // A fiber that will be called on each interrupt trigger. It sends a
        // single tick over the stream.
        fib::new_fn(|| fib::Yielded(Some(1))),
    );
    // Clear the current value of the timer.
    sys_tick.stk_val.store(|r| r.write_current(0));
    // Set the value to load into the `stk_val` register when the counter
    // reaches 0. We set it to the count of SysTick clocks per second, so the
    // reload will be triggered at each second.
    sys_tick.stk_load.store(|r| r.write_reload(SYS_TICK_FREQ));
    sys_tick.stk_ctrl.store(|r| {
        r.set_tickint() // Counting down to 0 triggers the SysTick interrupt
            .set_enable() // Start the counter
    });
<span class="boring">}
</span></code></pre></pre>
<p>Now the <code>tick_stream</code> variable holds an instance of a <code>Stream</code> type. We <code>await</code>
for each item of the stream until it ends. The <code>tick</code> variable is a number of
pulses (in our case seconds) passed since the last stream poll. If the thread is
not heavily interrupted, normally we expect it to be just <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    while let Some(tick) = tick_stream.next().await {
        for _ in 0..tick?.get() {
            println!(&quot;sec&quot;);
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Let's flash this program and view the SWO output:</p>
<pre><code class="language-shell">$ just flash
$ just log
</code></pre>
<p>You should see the following output. A &quot;sec&quot; line will be printed infinitely
each second.</p>
<pre><code class="language-text">================================== LOG OUTPUT ==================================
sec
sec
sec
sec
sec
</code></pre>
<p>Now it's time to use the GPIO peripheral, to drive the green LED on our Blue
Pill.</p>
<p><img src="bluepill-blink/../assets/bluepill-schematics-leds.png" alt="Blue Pill Schematics" /></p>
<p>According to the Blue Pill schematic above, the current is flowing through D2
when PC13 line is low (shorted to GND), and not flowing when its high (shorted
to VCC). Let's configure the PC13 pin, place this at the beginning of the
<code>beacon</code> function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    gpio_c.rcc_busenr_gpioen.set_bit(); // GPIO port C clock enable
    gpio_c.gpio_crh.modify(|r| {
        r.write_mode13(0b10) // Output mode, max speed 2 MHz
            .write_cnf13(0b00) // General purpose output push-pull
    });
<span class="boring">}
</span></code></pre></pre>
<p>Let's speed up our timer to wake up each 125 milliseconds. Update the <code>stk_load</code>
initialization code as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Set the value to load into the `stk_val` register when the counter
    // reaches 0. We set it to the count of SysTick clocks per second divided by
    // 8, so the reload will be triggered each 125 ms.
    sys_tick
        .stk_load
        .store(|r| r.write_reload(SYS_TICK_FREQ / 8));
<span class="boring">}
</span></code></pre></pre>
<p>Update the stream loop:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // A value cycling from 0 to 7. Full cycle represents a full second.
    let mut counter = 0;
    while let Some(tick) = tick_stream.next().await {
        for _ in 0..tick?.get() {
            // Each full second print a message.
            if counter == 0 {
                println!(&quot;sec&quot;);
            }
            match counter {
                // On 0's and 250's millisecond pull the pin low.
                0 | 2 =&gt; {
                    gpio_c.gpio_bsrr.br13.set_bit();
                }
                // On 125's, 375's, 500's, 625's, 750's, and 875's millisecond
                // pull the pin high.
                _ =&gt; {
                    gpio_c.gpio_bsrr.bs13.set_bit();
                }
            }
            counter = (counter + 1) % 8;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now flash the application to your Blue Pill board with:</p>
<pre><code class="language-shell">$ just flash
</code></pre>
<p>And you should see the following result:</p>
<video autoplay loop muted width="100%">
<source src="../assets/blink.webm" type="video/webm" />
<source src="../assets/blink.mp4" type="video/mp4" />
</video>
<p>The full code for this application can be found at
<a href="https://github.com/drone-os/bluepill-blink">Github</a>.</p>
<h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>Concurrency model is one of the most important aspects of an Embedded Operating
System. Applications for embedded micro-controllers require operating with
multiple sources of events at one time. Furthermore an embedded system should be
in a power-saving mode as often and as long as possible. Drone's goal is to make
writing highly concurrent and power-efficient applications easy and correct.</p>
<p>First, let's see how conventional Embedded Operating Systems work. They allow
you to create tasks that are running in parallel, each with its own stack:</p>
<p><img src="../assets/conventional-rtos.svg" alt="Conventional RTOS" /></p>
<p>However this is not how hardware is actually designed. In fact, processors can
only execute a single task at a time. What conventional Operating Systems
actually do, is that they are rapidly switching between tasks, to make them
<strong>appear</strong> to be running in parallel:</p>
<p><img src="../assets/conventional-rtos-slices.svg" alt="Conventional RTOS Time Sharing" /></p>
<p>That concurrency model, while having clear advantages for desktop and server
operating systems, incurs noticeable overhead for embedded real-time
systems. Also to protect from stack overflow errors it should be running on a
processor with built-in Memory Management/Protection Unit, which is not the case
for STM32F103.</p>
<p>Contrarily, modern hardware evolves in the direction of more elaborate interrupt
controllers. For example, Nested Vectored Interrupt Controller, or NVIC, which
can be found in each Cortex-M processor. It implements many hardware
optimizations to reduce scheduling costs, such as late-arriving or
tail-chaining. Drone OS utilizes such interrupt controllers to build strictly
prioritized fully preemptive scheduling:</p>
<p><img src="../assets/drone-single-stack.svg" alt="Drone Concurrency" /></p>
<p>Only a task with a higher priority can preempt another task. And a task must
completely relinquish the stack before completing or pausing to wait for an
event or a resource. This allows Drone OS to use a single stack for all program
tasks. This single stack is also protected from stack overflow errors by placing
it at the border of the RAM.</p>
<p>So how Drone achieves such stack usage for tasks? Mainly by using Rust's
async/await or generators syntax, which translate to state machines. The task
state, which needs to be saved between resumption points, is stored much more
compactly on the heap.</p>
<p>As an option Drone also implements conventional stateful tasks. Using such tasks
one can integrate an existing blocking code with a Drone application, by
allocating a separate stack. To use this feature safely, the processor must have
an MMU/MPU. Otherwise creating such task is <code>unsafe</code>, because the safety from
stack overflow couldn't be guaranteed.</p>
<h1 id="fibers"><a class="header" href="#fibers">Fibers</a></h1>
<p>Fibers in Drone OS are essentially finite-state machines. On type level, a fiber
is an instance of an anonymous type, which implements the <code>Fiber</code> trait. The
trait is defined at <code>drone_core::fib</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fiber {
    type Input;
    type Yield;
    type Return;

    fn resume(
        self: Pin&lt;&amp;mut Self&gt;,
        input: Self::Input,
    ) -&gt; FiberState&lt;Self::Yield, Self::Return&gt;;
}

pub enum FiberState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Fiber</code> and <code>FiberState</code> are similar to <code>Generator</code> and <code>GeneratorState</code> from
<code>core::ops</code>, but with addition of the input parameter. Also like generators, it
is invalid to resume a fiber after completion.</p>
<p>A fiber can be created in multiple ways using <code>drone_cortexm::fib::new_*</code> family
of constructors. For example a fiber that completes immediately upon resumption
can be created from an <code>FnOnce</code> closure:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::pin::Pin;
use drone_cortexm::{
    fib,
    fib::{Fiber, FiberState},
};

let mut fiber = fib::new_once(|| 4);
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(4));
<span class="boring">}
</span></code></pre></pre>
<p>A fiber that involves multiple yield points before completion can be created
from an <code>FnMut</code> closure:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut state = 0;
let mut fiber = fib::new_fn(move || {
    if state &lt; 3 {
        state += 1;
        fib::Yielded(state)
    } else {
        fib::Complete(state)
    }
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
<span class="boring">}
</span></code></pre></pre>
<p>Or an equivalent fiber can be created using Rust's generator syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut fiber = fib::new(|| {
    let mut state = 0;
    while state &lt; 3 {
        state += 1;
        yield state;
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
<span class="boring">}
</span></code></pre></pre>
<p>The fibers described in this chapter are the main building blocks for Drone OS
tasks. But there is one more type of fibers, which will be described in the next
chapter.</p>
<h1 id="processes"><a class="header" href="#processes">Processes</a></h1>
<p>Processes in Drone OS are special kind of fibers, that can be suspended with a
special blocking call. They use dedicated dynamically allocated stacks. On
Cortex-M platform, Drone implements processes using <code>SVC</code> assembly instruction
and SVCall exception. So before using processes, a Drone supervisor should be
added to the project.</p>
<h2 id="supervisor"><a class="header" href="#supervisor">Supervisor</a></h2>
<p>Create a new file at <code>src/sv.rs</code> with the following content:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! The supervisor.

use drone_cortexm::{
    sv,
    sv::{SwitchBackService, SwitchContextService},
};

sv::pool! {
    /// Pool of services.
    pool =&gt; SERVICES;

    /// Supervisor type.
    supervisor =&gt; pub Sv;

    // Attached services.
    services =&gt; {
        SwitchContextService;
        SwitchBackService;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And register the newly created module in the <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod sv;
<span class="boring">}
</span></code></pre></pre>
<p>Update <code>thr::nvic!</code> macro inside <code>src/thr.rs</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::sv::Sv;

thr::nvic! {
    supervisor =&gt; Sv; // &lt;-- register the supervisor type

    // ... other configuration is skipped ...

    threads =&gt; {
        exceptions =&gt; {
            /// All classes of faults.
            pub hard_fault;
            // Define an external function handler for the SV_CALL exception.
            naked(sv::sv_handler::&lt;Sv&gt;) sv_call;
        };
    };
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-processes"><a class="header" href="#using-processes">Using processes</a></h2>
<p>First, let's recall the generator fiber example from the previous chapter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::pin::Pin;
use drone_cortexm::{
    fib,
    fib::{Fiber, FiberState},
};

let mut fiber = fib::new(|| {
    let mut state = 0;
    while state &lt; 3 {
        state += 1;
        yield state;
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
<span class="boring">}
</span></code></pre></pre>
<p>This fiber can be rewritten using Drone process as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::sv::Sv;
use core::pin::Pin;
use drone_cortexm::{
    fib,
    fib::{Fiber, FiberState},
};

let mut fiber = fib::new_proc::&lt;Sv, _, _, _, _&gt;(128, |_, yielder| {
    let mut state = 0;
    while state &lt; 3 {
        state += 1;
        yielder.proc_yield(state);
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
<span class="boring">}
</span></code></pre></pre>
<p>The difference is that the code inside the closure argument is fully
synchronous. The <code>proc_yield</code> call is translated to the <code>SVC</code> assembly
instruction. This instruction immediately switches the execution context back to
the caller. When the <code>resume</code> method of the process is called, it continues from
the last yield point, just like a generator.</p>
<p>The <code>fib::new_proc</code> function takes a stack size as the first argument. The stack
will be immediately allocated from the heap. To make this function safe, the
processor's MPU used to protect the stack from a possible overflow. On
processors without MPU, like STM32F103, this function will panic. However it is
still possible to use processes on such systems, though without any guarantees
about stack overflows. You can use <code>new_proc_unchecked</code> function, which is
marked <code>unsafe</code>.</p>
<p>Unlike generators, a process can take input data. And unlike <code>yield</code> keyword,
the <code>proc_yield</code> function not necessarily returns <code>()</code>. Here is an example of
such process:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut fiber = fib::new_proc::&lt;Sv, _, _, _, _&gt;(128, |input, yielder| {
    let mut state = input;
    while state &lt; 4 {
        state += yielder.proc_yield(state);
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(1), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(2), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(3), FiberState::Complete(6));
<span class="boring">}
</span></code></pre></pre>
<h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>A thread in Drone OS corresponds to a hardware interrupt. It is a sequence of
fibers that managed independently by an interrupt controller. Threads can not be
created on demand, but should be pre-defined for a particular project. Then any
number of fibers can be attached dynamically to a particular thread.</p>
<p>Threads should be defined at <code>src/thr.rs</code> using <code>thr::nvic!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thr::nvic! {
    /// Thread-safe storage.
    thread =&gt; pub Thr {};

    /// Thread-local storage.
    local =&gt; pub ThrLocal {};

    /// Vector table.
    vtable =&gt; pub Vtable;

    /// Thread token set.
    index =&gt; pub Thrs;

    /// Threads initialization token.
    init =&gt; pub ThrsInit;

    threads =&gt; {
        exceptions =&gt; {
            /// All classes of faults.
            pub hard_fault;
        };
        interrupts =&gt; {
            /// A thread for my task.
            10: pub my_thread;
        };
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>The macros will define <code>THREADS</code> static array of <code>Thr</code> objects. In this example
the array will contain three element: <code>HARD_FAULT</code>, <code>MY_THREAD</code>, and the
implicit <code>RESET</code> thread data. <code>Thrs</code> structure is also created here, which is a
zero-sized type, a set of tokens, through which one can manipulate the
threads. This set of token can be instantiated only once, usually at the very
beginning of the root task:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let thr = thr::init(thr_init);

    // ... The rest of the handler ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the <code>thr</code> variable contains tokens for all defined threads. If you have
added fields to the <code>Thr</code> definition, they are accessible through
<code>thr.my_thread.to_thr()</code>. <code>ThrLocal</code> is also stored inside <code>Thr</code>, but accessible
only through the <code>Thr::local()</code> associated function.</p>
<p>A thread can be called programmatically using implicit <code>core::task::Waker</code> or
explicit <code>thr.my_thread.trigger()</code> or directly by hardware peripherals. If the
thread, which was triggered, has a higher priority than the currently active
thread, the active thread will be preempted. If the thread has a lower priority,
it will run after all higher priority threads. Priorities can be changed on the
fly with <code>thr.my_thread.set_priority(...)</code> method.</p>
<h2 id="fiber-chain"><a class="header" href="#fiber-chain">Fiber chain</a></h2>
<p>The main thing a thread owns is a fiber chain. A fiber chain is essentially a
linked list of fibers. A fiber can be added to a thread chain dynamically using
<code>thr.my_thread.add_fib(...)</code>, or other methods based on it. The <code>add_fib</code> method
is atomic, i.e. fibers can be added to a particular thread from other threads.</p>
<p>When a thread is triggered, it runs the fibers in its fiber chain one-by-one in
LIFO order. In other words the most recently added fiber will be executed
first. A fiber can return <code>fib::Yielded</code> result, which means the fiber is paused
but not completed; the thread will keep the fiber in place for the later run and
proceed with the next fiber in the chain. Or the fiber can return
<code>fib::Complete</code>, in which case the thread removes the fiber from the chain, runs
its <code>drop</code> destructor, and proceeds to the next fiber in the chain.</p>
<h1 id="tasks"><a class="header" href="#tasks">Tasks</a></h1>
<p>In Drone OS applications, a task is a logical unit of work. Most often it's
represented as an <code>async</code> function that's running in a separate thread. By
convention, each task is placed into a separate module inside <code>src/tasks</code>
directory. The module contains at least a task main function named
<code>handler</code>. The function then re-exported in <code>src/tasks/mod.rs</code> like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod my_task;

pub use self::my_task::handler as my_task;
<span class="boring">}
</span></code></pre></pre>
<p>It is common to use an unused interrupt as the task thread. For example, in
STM32F103, there is &quot;UART5 global interrupt&quot; at the position 53. If UART5
peripheral is not used by the application, its interrupt can be reused for a
completely different task:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thr::nvic! {
    // ... The header is skipped ...

    threads =&gt; {
        exceptions =&gt; {
            /// All classes of faults.
            pub hard_fault;
        };
        interrupts =&gt; {
            /// A thread for `my_task`.
            53: pub my_task;
        };
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, assuming <code>my_task</code> is an <code>async</code> function, the thread can run the task as
follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::tasks;
use drone_cortexm::thr::prelude::*;

thr.my_task.enable_int();
thr.my_task.set_priority(0xB0);
thr.my_task.exec(tasks::my_task());
<span class="boring">}
</span></code></pre></pre>
<p>Now, whenever <code>my_task</code> future or any of its nested futures returns
<code>Poll::Pending</code>, the thread suspends. And it will be resumed when the future
will be ready for polling again. It is implemented by passing a
<code>core::task::Waker</code> behind the scenes, which will trigger the thread when
<code>wake</code>d.</p>
<h1 id="message-passing"><a class="header" href="#message-passing">Message-Passing</a></h1>
<p>The preferred way for inter-thread communication in Drone OS is
message-passing. In a similar way as Rust's stdlib offers <code>std::sync::mpsc</code> for
multi-producer single-consumer queues, Drone offers three different kinds of
single-producer single-consumer queues under <code>drone_core::sync::spsc</code>.</p>
<h2 id="oneshot"><a class="header" href="#oneshot">Oneshot</a></h2>
<p>The oneshot channel is used to transfer an ownership of a single value from one
thread to another. You can create a channel like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use drone_core::sync::spsc::oneshot;

let (tx, rx) = oneshot::channel();
<span class="boring">}
</span></code></pre></pre>
<p><code>tx</code> and <code>rx</code> are transmitting and receiving parts respectively, they can be
passed to different threads. The <code>tx</code> part has a <code>send</code> method, which takes
<code>self</code> by value, meaning it can be called only once:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tx.send(my_message);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>rx</code> part is a future, which means it can be <code>.await</code>ed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_message = rx.await;
<span class="boring">}
</span></code></pre></pre>
<h2 id="ring"><a class="header" href="#ring">Ring</a></h2>
<p>For passing multiple values of one type, there is the ring channel. It works by
allocating a fixed-size ring-buffer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use drone_core::sync::spsc::ring;

let (tx, rx) = ring::channel(100);
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>100</code> is the size of the underlying ring buffer. The <code>tx</code> part is used to
send values over the channel:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tx.send(value1);
tx.send(value2);
tx.send(value3);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>rx</code> part is a stream:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(value) = rx.next().await {
    // new value received
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="pulse"><a class="header" href="#pulse">Pulse</a></h2>
<p>When you need to repeatedly notify the other thread about some event, but
without any payload, the ring channel might be an overkill. There is the pulse
channel, which is backed by an atomic counter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use drone_core::sync::spsc::pulse;

let (tx, rx) = pulse::channel();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>tx</code> part has a <code>send</code> method, which takes a number to add to the underlying
counter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tx.send(1);
tx.send(3);
tx.send(100);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>rx</code> part is a stream. Each successful poll of the stream clears the
underlying counter and returns the number, which was stored:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(pulses) = rx.next().await {
    // `pulses` number of events was happened since the last poll
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="futures-and-streams"><a class="header" href="#futures-and-streams">Futures and streams</a></h2>
<p>Thread tokens have methods that helps creating described channels for connecting
with a particular thread.</p>
<p><code>add_future</code> takes a fiber and returns a future (<code>rx</code> part of a oneshot
channel). The future will be resolved when the fiber returns <code>fib::Complete</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use drone_cortexm::{fib, thr::prelude::*};

let pll_ready = thr.rcc.add_future(fib::new_fn(|| {
    if pll_ready_flag.read_bit() {
        fib::Complete(())
    } else {
        fib::Yielded(())
    }
}));
pll_ready.await;
<span class="boring">}
</span></code></pre></pre>
<p><code>add_try_stream</code> returns a stream (<code>rx</code> part of a ring channel), which resolves
each time the fiber returns <code>fib::Yielded(Some(...))</code> or
<code>fib::Complete(Some(...))</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use drone_cortexm::{fib, thr::prelude::*};

let uart_bytes = thr.uart.add_try_stream(
    100, // The ring buffer size
    || panic!(&quot;Ring buffer overflow&quot;),
    fib::new_fn(|| {
        if let Some(byte) = read_uart_byte() {
            fib::Yielded(Some(byte))
        } else {
            fib::Yielded(None)
        }
    }),
);
<span class="boring">}
</span></code></pre></pre>
<p><code>add_pulse_try_stream</code> returns a stream (<code>rx</code> part of pulse channel), which
resolves each time the fiber returns <code>fib::Yielded(Some(number))</code> or
<code>fib::Complete(Some(number))</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use drone_cortexm::{fib, thr::prelude::*};

let sys_tick_stream = thr.sys_tick.add_pulse_try_stream(
    || panic!(&quot;Counter overflow&quot;),
    fib::new_fn(|| fib::Yielded(Some(1))),
);
<span class="boring">}
</span></code></pre></pre>
<h1 id="dynamic-memory"><a class="header" href="#dynamic-memory">Dynamic Memory</a></h1>
<p>In order to unleash the full potential of Rust type system, Drone OS provides a
global allocator. This might seem paradoxical, but addition of some run-time
dynamism helps with compile-time checks. Consider the signature of
<code>thread::spawn</code> function from libstd:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static;
<span class="boring">}
</span></code></pre></pre>
<p>This means that in <code>std</code> applications to spawn a new OS thread, one need to call
the <code>thread::spawn</code> function in the run-time, passing it a closure of type
<code>F</code>. An interesting aspect here is the <code>F: Send + 'static</code> bound. This
guarantees that the data captured by the closure is also <code>Send</code> and
<code>'static</code>. <code>'static</code> rejects references that has a narrower scope than the
entire program. And <code>Send</code> rejects thread-unsafe types. A nice thing here is
that all of these properties are checked in the compile-time. Naturally,
equivalent functions in Drone OS have similar signatures.</p>
<p>An allocator for embedded systems should meet the following conditions:</p>
<ol>
<li>
<p>Determinism. For real-time systems, it is important that allocation,
deallocation, and reallocation operations have predictable timing.</p>
</li>
<li>
<p>Small code size. For example jemalloc can add hundreds of kilobytes to the
binary size, while some supported MCUs have 64 KB of flash memory or even
less.</p>
</li>
</ol>
<p>Drone OS ships with a simple and predictable allocator, which fulfills the above
conditions. It splits the whole heap memory region into a number of fixed-sized
memory pools:</p>
<p><img src="../assets/heap-pools.svg" alt="Memory Pools" /></p>
<p>The pools are configured at the compile-time in the <code>Drone.toml</code>. For example:</p>
<pre><code class="language-toml">[heap.main]
size = &quot;10K&quot;
pools = [
    { block = &quot;4&quot;, capacity = 118 },
    { block = &quot;8&quot;, capacity = 148 },
    { block = &quot;20&quot;, capacity = 82 },
    { block = &quot;56&quot;, capacity = 34 },
    { block = &quot;116&quot;, capacity = 16 },
    { block = &quot;208&quot;, capacity = 8 },
    { block = &quot;336&quot;, capacity = 3 },
    { block = &quot;512&quot;, capacity = 1 },
]
</code></pre>
<p>In result, the Drone allocator achieves all its operations to be constant-time
and entirely atomic. However, a disadvantage of this approach is that in order
to use the memory efficiently, the pools need to be tuned for each particular
application. Drone provides tools to make it as easy as possible, which we will
cover in the next chapter.</p>
<p>By providing a global allocator, a Drone application can use not only the Rust's
<code>core</code> crate, but also the <code>alloc</code> crate. It enables one to use the following
Rust types: <code>String</code>, <code>Vec</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, and more.</p>
<h1 id="heap-tracing"><a class="header" href="#heap-tracing">Heap Tracing</a></h1>
<p>Drone OS provides tools to fine-tune the built-in allocator for purposes of a
particular application.</p>
<p>A newly generated Drone project has the following <code>heap!</code> macro in <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>heap! {
    // Heap configuration key in `Drone.toml`.
    config =&gt; main;
    /// The main heap allocator generated from the `Drone.toml`.
    metadata =&gt; pub Heap;
    // Use this heap as the global allocator.
    global =&gt; true;
    // Uncomment the following line to enable heap tracing feature:
    // trace_port =&gt; 31;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that <code>trace_port</code> option is commented out - by default the firmware
compiles without the heap tracing runtime. When the option is uncommented, the
heap allocator will log its operations to the log port #31. In order to capture
these logs, first uncomment the <code>trace_port</code> option:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>heap! {
    // ... The header is skipped ...

    // Uncomment the following line to enable heap tracing feature:
    trace_port =&gt; 31;
}
<span class="boring">}
</span></code></pre></pre>
<p>Then flash the new version of the application firmware to the target device:</p>
<pre><code class="language-shell">$ just flash
</code></pre>
<p>Then you run a special recipe to capture the data:</p>
<pre><code class="language-shell">$ just heaptrace
</code></pre>
<p>This recipe is similar to <code>just log</code>, with an exception that it will
additionally capture port #31 output and write it to a file named
<code>heaptrace</code>. When you think it is enough data collected, just stop it with
Ctrl-C.</p>
<p>When there is a non-empty <code>heaptrace</code> file with the collected data in the
project root, you may use the following command to analyze your heap usage:</p>
<pre><code class="language-shell">$ drone heap
</code></pre>
<p>It will print statistics of all your allocations during <code>just heaptrace</code>:</p>
<pre><code class="language-text"> Block Size | Max Load | Total Allocations
------------+----------+-------------------
          1 |        1 |                 1
         12 |        3 |                 7
         28 |        1 |                 2
         32 |        1 |                 1
        128 |        1 |                 2

Maximum memory usage: 225 / 2.20%
</code></pre>
<p>The data in the <code>heaptrace</code> file can also be used to generate an optimized
memory pools layout:</p>
<pre><code class="language-shell">$ drone heap generate --pools 5
</code></pre>
<p>Here <code>5</code> is the maximum number of pools. Less pools lead to more fragmentation,
but faster allocations. You should get something like this:</p>
<pre><code class="language-text">=============================== SUGGESTED LAYOUT ===============================
[heap]
size = &quot;10K&quot;
pools = [
    { block = &quot;4&quot;, capacity = 201 },
    { block = &quot;12&quot;, capacity = 222 },
    { block = &quot;28&quot;, capacity = 115 },
    { block = &quot;32&quot;, capacity = 83 },
    { block = &quot;128&quot;, capacity = 7 },
]
# Fragmentation: 0 / 0.00%
</code></pre>
<p>It generated a <code>[heap]</code> section suitable to put into the <code>Drone.toml</code>.</p>
<h1 id="memory-mapped-registers"><a class="header" href="#memory-mapped-registers">Memory-Mapped Registers</a></h1>
<p>Modern processor architectures (e.g. ARM) use memory-mapped I/O to perform
communication between the CPU and peripherals. Using memory-mapped registers is
a considerable part in programming for microcontroller. Therefore Drone OS
provides a complex API, which provides convenient access to them without
data-races.</p>
<p>For example in STM32F103, the memory address of <code>0x4001100C</code> corresponds to the
GPIOC_ODR register. This is a register to control the output state of the GPIO
port C peripheral.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::ptr::write_volatile;

unsafe {
    write_volatile(0x4001_100C as *mut u32, 1 &lt;&lt; 13);
}
<span class="boring">}
</span></code></pre></pre>
<p>The above code is an example how to write to a memory-mapped register in bare
Rust, without Drone. It sets PC13 pin output to logic-high (resetting all other
port C pins to logic-low.) This code is too low-level and error-prone, and also
requires an <code>unsafe</code> block.</p>
<p>For Cortex-M there is SVD (System View Description) format. Vendors generally
provide files of this format for their Cortex-M MCUs. Drone generates
MCU-specific register API from these files for each supported target. So copying
addresses and offsets from reference manuals generally is not needed.</p>
<p>Let's look at the default <code>reset</code> function in <code>src/bin/&lt;crate-name&gt;.rs</code>, which
is the entry-point of the program:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe extern &quot;C&quot; fn reset() -&gt; ! {
    mem::bss_init();
    mem::data_init();
    tasks::root(Regs::take(), ThrsInit::take());
    loop {
        processor::wait_for_int();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This <code>unsafe</code> function performs all necessary initialization routines before
calling the safe <code>root</code> entry task. This includes <code>Regs::take()</code> and
<code>ThrsInit::take()</code> calls. These calls create instances of <code>Regs</code> and <code>ThrsInit</code>
types, which are zero-sized types. The calls are <code>unsafe</code>, because they must be
done only once in the whole program run-time.</p>
<p>Let's now check the <code>tasks::root</code> function (it is re-exported from <code>handler</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handler(reg: Regs, thr_init: ThrsInit) {
    // Enter a sleep state on ISR exit.
    reg.scb_scr.sleeponexit.set_bit();
}
<span class="boring">}
</span></code></pre></pre>
<p><code>reg</code> is an open-struct (all fields of the struct are <code>pub</code>) and consists of all
available register tokens. Each register token is also an open-struct and
consists of register field tokens. So this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    reg.scb_scr.sleeponexit.set_bit();
<span class="boring">}
</span></code></pre></pre>
<p>Sets SLEEPONEXIT bit of SCB_SCR register.</p>
<p>Of course no real-world application would use all available memory-mapped
registers. The <code>reg</code> object is supposed to be destructured within the <code>root</code>
task handler and automatically dropped. To make this more readable, we move
individual tokens out of <code>reg</code> in logical blocks using macros:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let gpio_c = periph_gpio_c!(reg);
    let sys_tick = periph_sys_tick!(reg);
    beacon(gpio_c, sys_tick)
}
<span class="boring">}
</span></code></pre></pre>
<p>These macros use partial-moving feature of Rust and expand roughly as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let gpio_c = GpioC {
        gpio_crl: reg.gpio_crl,
        gpio_crh: reg.gpio_crh,
        gpio_idr: reg.gpio_idr,
        gpio_odr: reg.gpio_odr,
        // Notice that below are individual fields.
        // Other APB2 peripherals may take other fields from this same registers.
        rcc_apb2enr_iopcen: reg.rcc_apb2enr.iopcen,
        rcc_apb2enr_iopcrst: reg.rcc_apb2enr.iopcrst,
        // ...
    };
    let sys_tick = SysTick {
        stk_ctrl: reg.stk_ctrl,
        stk_load: reg.stk_load,
        stk_val: reg.stk_val,
        scb_icsr_pendstclr: reg.scb_icsr.pendstclr,
        scb_icsr_pendstset: reg.scb_icsr.pendstset,
    };
    beacon(gpio_c, sys_tick)
}
<span class="boring">}
</span></code></pre></pre>
<p>If you wonder why we use macros instead of functions, the following example
shows why functions wouldn't work:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn periph_gpio_c(reg: Regs) -&gt; GpioC {
    GpioC {
        gpio_crl: reg.gpio_crl,
        gpio_crh: reg.gpio_crh,
        gpio_idr: reg.gpio_idr,
        gpio_odr: reg.gpio_odr,
        // Notice that below are individual fields.
        // Other APB2 peripherals may take other fields from this same registers.
        rcc_apb2enr_iopcen: reg.rcc_apb2enr.iopcen,
        rcc_apb2enr_iopcrst: reg.rcc_apb2enr.iopcrst,
        // ...
    }
}

fn periph_sys_tick(reg: Regs) -&gt; GpioC {
    SysTick {
        stk_ctrl: reg.stk_ctrl,
        stk_load: reg.stk_load,
        stk_val: reg.stk_val,
        scb_icsr_pendstclr: reg.scb_icsr.pendstclr,
        scb_icsr_pendstset: reg.scb_icsr.pendstset,
    }
}

pub fn handler(reg: Regs, thr_init: ThrsInit) {
            // --- move occurs because `reg` has type `Regs`, which
            //     does not implement the `Copy` trait
    let gpio_c = periph_gpio_c(reg);
                            // --- value moved here
    let sys_tick = periph_sys_tick(reg);
                                // --- value used here after move
    beacon(gpio_c, sys_tick)
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="memory-mapped-registers-api-summary"><a class="header" href="#memory-mapped-registers-api-summary">Memory-Mapped Registers API Summary</a></h1>
<p>This section provides examples of most common methods on register and field
tokens. For complete API refer to <code>drone_core::reg</code> and <code>drone_cortexm::reg</code>
module docs.</p>
<h2 id="whole-registers"><a class="header" href="#whole-registers">Whole Registers</a></h2>
<p>Read the value of RCC_CR register:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = rcc_cr.load();
<span class="boring">}
</span></code></pre></pre>
<p>HSIRDY is a single-bit field, so this method returns a <code>bool</code> value indicating
whether the corresponding bit is set or cleared:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>val.hsirdy() // equivalent to `val &amp; (1 &lt;&lt; 1) != 0`
<span class="boring">}
</span></code></pre></pre>
<p>HSITRIM is a 5-bit field in the middle of the RCC_CR register. This method
returns an integer of only this field bits shifted to the beginning:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>val.hsitrim() // equivalent to `(val &gt;&gt; 3) &amp; ((1 &lt;&lt; 5) - 1)`
<span class="boring">}
</span></code></pre></pre>
<p>Reset the register RCC_CR to its default value, which is specified in the
reference manual:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rcc_cr.reset();
<span class="boring">}
</span></code></pre></pre>
<p>The following line writes a new value to the RCC_CR register. The value is the
register default value, except HSION is set to 1 and HSITRIM is set to 14.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rcc_cr.store(|r| r.set_hsion().write_hsitrim(14));
// Besides &quot;set_&quot;, there are &quot;clear_&quot; and &quot;toggle_&quot; prefixes
// for single-bit fields.
<span class="boring">}
</span></code></pre></pre>
<p>And finally the following line is a combination of all of the above, it performs
read-modify-write operation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rcc_cr.modify(|r| r.set_hsion().write_hsitrim(14));
<span class="boring">}
</span></code></pre></pre>
<p>Unlike <code>store</code>, which resets unspecified fields to the default, the <code>modify</code>
method keeps other field values intact.</p>
<h2 id="register-fields"><a class="header" href="#register-fields">Register Fields</a></h2>
<p>If you have only a register field token, you can perform operations affecting
only this field, and not the other sibling fields:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rcc_cr_hsirdy.read_bit(); // equivalent to `rcc_cr.load().hsirdy()`
rcc_cr_hsitrim.read_bits(); // equivalent to `rcc_cr.load().hsitrim()`
rcc_cr_hsirdy.set_bit(); // equivalent to `rcc_cr.modify(|r| r.set_hsirdy())`
rcc_cr_hsirdy.clear_bit(); // equivalent to `rcc_cr.modify(|r| r.clear_hsirdy())`
rcc_cr_hsirdy.toggle_bit(); // equivalent to `rcc_cr.modify(|r| r.toggle_hsirdy())`
rcc_cr_hsitrim.write_bits(14); // equivalent to `rcc_cr.modify(|r| r.write_hsitrim(14))`
<span class="boring">}
</span></code></pre></pre>
<p>Also if you have tokens for several fields of the same register, you can perform
a single read-modify-write operation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rcc_cr_hsion.modify(|r| {
    rcc_cr_hsion.set(r);
    rcc_cr_hsitrim.write(r, 14);
});
// Which would be equivalent to:
rcc_cr.modify(|r| r.set_hsion().write_hsitrim(14));
<span class="boring">}
</span></code></pre></pre>
<h1 id="memory-mapped-register-token-tags"><a class="header" href="#memory-mapped-register-token-tags">Memory-Mapped Register Token Tags</a></h1>
<p>Let's take a closer look at what exact type a register token has:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let rcc_cr: reg::rcc::Cr&lt;Srt&gt; = reg.rcc_cr;
}
<span class="boring">}
</span></code></pre></pre>
<p>A register token tag has one generic parameter - a register tag. There are three
possible register tags:</p>
<ul>
<li><code>Urt</code> (for <strong>U</strong>nsynchronized <strong>r</strong>egister <strong>t</strong>ag)</li>
<li><code>Srt</code> (for <strong>S</strong>ynchronized <strong>r</strong>egister <strong>t</strong>ag)</li>
<li><code>Crt</code> (for <strong>C</strong>opyable <strong>r</strong>egister <strong>t</strong>ag)</li>
</ul>
<p>The tags are crucial to eliminate data-races for read-modify-write operations
and to control move-semantics of the tokens.</p>
<p><img src="reg/../assets/reg-tags.svg" alt="Register Token Tags" /></p>
<p>Here <code>RegOwned</code> is a kind of tag that <em>doesn't</em> implement the <code>Copy</code> trait, and
<code>RegAtomic</code> makes all read-modify-write operations atomic.</p>
<p>Operations for register tokens and field tokens without an atomic tag (<code>Urt</code>)
require exclusive (<code>&amp;mut</code>) borrows. While atomic tokens (<code>Srt</code>, <code>Crt</code>) require
shared (<code>&amp;</code>) borrows. This eliminates any possibility of data-races by
leveraging Rust compile-time checking. Despite <code>Urt</code> tagged tokens use more
effective, but non-atomic processor instructions, it is impossible to use
concurrently. A program with a possible data-race will be rejected by the
compiler, and there are no additional checks in the run-time.</p>
<p>For the whole register tokens, the only affected operation in regard to
atomicity is the <code>modify</code> method. However for the field tokens, all write
operations incur additional cost if used with an atomic tag. Because field
tokens could be shared between different threads.</p>
<p>Another property of a token is affinity (expressed by the <code>RegOwned</code> trait.) An
affine type can't be copied nor cloned, and uses Rust move-semantics. If a token
has an affine tag (<code>Urt</code>, <code>Srt</code>), it is guaranteed that there exists only one
token for this particular register or field. Though such tokens could still have
multiple shared borrows. Non-affine (<code>Crt</code>) tokens can be freely copied, because
they implement the <code>Copy</code> trait. Copying of tokens is still zero-cost, because
tokens are zero-sized. On the other hand copyable tokens are always atomic.</p>
<p>To switch between different tags of tokens, both whole register tokens and
register field tokens provide the following three methods:</p>
<ul>
<li><code>into_unsync()</code> - converts to unsynchronized token</li>
<li><code>into_sync()</code> - converts to synchronized token</li>
<li><code>into_copy()</code> - converts to copyable token</li>
</ul>
<p>These methods take their tokens by-value, and return a new token of the same
type but with a different tag. Not all conversions are possible. For example if
a token is already <code>Crt</code>, there is no path backwards to <code>Srt</code> or <code>Urt</code>. Because
we can't guarantee that all possible copies of the <code>Crt</code> token are dropped. For
the details refer to the <code>drone_core::reg</code> documentation. As one might guess,
these conversion methods are completely zero-cost.</p>
<h1 id="peripheral-mappings"><a class="header" href="#peripheral-mappings">Peripheral Mappings</a></h1>
<p>Peripheral mappings serves two main purposes: grouping memory-mapped registers
and individual register fields together in a single block for convenient use,
and making one generic block for multiple peripherals of the same type
(e.g. SPI1, SPI2, SPI3).</p>
<p>While register mappings we are able to generate almost automatically from SVD
files (they are often of poor quality, and require manual fix-ups), we define
peripheral mappings manually for each supported target with help of powerful
procedure macros. For this reason we can't map all available peripherals for all
targets, but we strive the mapping process to be as easy as possible. So users
could map missing peripherals by themselves, and maybe contribute it back to
Drone OS. For the details how to create peripheral mappings, refer to the
<code>drone_core::periph</code> documentation.</p>
<p>A peripheral mapping defines a macro to acquire all needed register tokens. In
the following example, <code>periph_gpio_c!</code> and <code>periph_sys_tick!</code> are such macros:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handler(reg: Regs, thr_init: ThrsInit) {
    let gpio_c = periph_gpio_c!(reg);
    let sys_tick = periph_sys_tick!(reg);
    beacon(gpio_c, sys_tick)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>gpio_c</code> and <code>sys_tick</code> objects are zero-sized, and these lines of code incur no
run-time cost. These objects hold all relevant register and field tokens for the
corresponding peripherals. It is impossible to create two instances for a single
peripheral, because after the first macro call the <code>reg</code> object becomes
partially-moved.</p>
<p>The <code>beacon</code> function could be defined as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn beacon(
    gpio_c: GpioPortPeriph&lt;GpioC&gt;,
    sys_tick: SysTickPeriph,
) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the type of <code>gpio_c</code> argument is a generic struct, because there are
many possible peripherals with the same interface: <code>GpioA</code>, <code>GpioB</code>, <code>GpioC</code>,
and so on. Conversely, the <code>sys_tick</code> type is not generic, because there is only
one SysTick peripheral in the chip. We could easily define the <code>beacon</code> function
to be generic over GPIO port:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn beacon&lt;GpioPort: GpioPortMap&gt;(
    gpio_c: GpioPortPeriph&lt;GpioPort&gt;,
    sys_tick: SysTickPeriph,
) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a preferred and very handy way to define drivers. We don't want to
hard-code an SD-card driver to use for example only SPI3. An alternative
approach would be to wrap the whole driver code into a macro, and call it with
SPI1, SPI2, SPI3 arguments. But we believe this would be a less clean and
idiomatic way.</p>
<h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Testing Embedded Systems is more difficult than testing standard
applications. There are at least two hardware platforms involved: the one that
runs the compiler, and the target system. Testing on the development machine is
much easier, but it can't test hardware-specific code. Conversely, testing
directly on the target system is much harder and requires elaborate hardware
setup.</p>
<p>Drone OS supports testing on the development machine out of the box. Drone
crates as well as all projects generated with <code>drone new</code> have a special
feature, named <code>std</code>. When you run the test recipe:</p>
<pre><code class="language-shell">$ just test
</code></pre>
<p>Your program is compiled for your development machine target (usually
<code>x86_64-unknown-linux-gnu</code>), and not for your device target
(e.g. <code>thumbv7m-none-eabi</code>). And the program is compiled with the <code>std</code> feature
enabled. This allows to run standard Rust's test runner.</p>
<p>This way you can use all standard Rust testing options: inline <code>#[test]</code>
functions, separate test files under <code>tests/</code> directory, documentation tests
(including <code>compile_fail</code> tests.) Also your tests have access to the <code>std</code>
crate.</p>
<p>Though, you should keep in mind that the pointer size in your tests and in the
release code will usually differ. This kind of tests is suitable for testing
algorithms and business logic. Hardware-specific code often will not even
compile. For this, you should use condition compilation like in this snippet
from <code>drone-cortexm</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn wait_for_int() {
    #[cfg(feature = &quot;std&quot;)]
    return unimplemented!();
    unsafe { asm!(&quot;wfi&quot; :::: &quot;volatile&quot;) };
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="drone-os-extensibility"><a class="header" href="#drone-os-extensibility">Drone OS Extensibility</a></h1>
<p>Drone is designed to be maximally extensible to various platforms. It is
composed of a complex hierarchy of Rust crates. Where the main foundational part
if fully platform-agnostic, and platform-specific crates are built on top of it.</p>
<p>The core part of Drone makes little to no assumptions about the platform it will
be running on. One exception is that the platform should have a good support of
atomic operations on the instruction level. Drone tries hard to never use
disabling of interrupts to protect its shared data-structures.</p>
<p>In this section we will review Drone crates hierarchy by the example of Nordic
Semiconductor's nRF91 microcontroller series.</p>
<p><img src="../assets/crates-hierarchy.svg" alt="Crates Hierarchy" /></p>
<p>The crates composed of the following workspaces:</p>
<ul>
<li>
<p><strong>drone</strong> - Drone command-line utility.</p>
</li>
<li>
<p><strong>drone-core</strong> - Drone core functionality.</p>
</li>
<li>
<p><strong>drone-cortexm</strong> - ARM® Cortex®-M support.</p>
</li>
<li>
<p><strong>drone-svd</strong> - CMSIS-SVD file format parser.</p>
</li>
<li>
<p><strong>drone-nrf-map</strong> - Nordic Semiconductor nRFx mappings.</p>
</li>
<li>
<p><strong>drone-nrf91-dso</strong> - Drone Serial Output implementation for Nordic
Semiconductor nRF91.</p>
</li>
</ul>
<h2 id="adding-new-chip-support"><a class="header" href="#adding-new-chip-support">Adding New Chip Support</a></h2>
<p>In order to add Drone support for a not-yet-supported chip, firstly we need to
determine its platform. If the platform is not yet supported, e.g. RISC-V, we
start by creating <code>drone-riscv</code> crate. If the platform is already supported,
e.g. Cortex-M, but the platform version is not yet supported, e.g. Cortex-M23,
we extend the existing <code>drone-cortexm</code> crate.</p>
<p>When we have the platform support, we need to add registers and interrupt
mappings. We need to find out if there is already a crate for the chip
series. If there is no such crate, e.g. Texas Instruments SimpleLink™, we need
to create one: <code>drone-tisl-map</code>. If, for example, we need to add support for
STM32WB55, we need to extend the existing <code>drone-stm32-map</code> crate.</p>
<p>If the chip doesn't have hardware logging capabilities (e.g. SWO), we need to
write a crate, which implements DSO (Drone Serial Output) protocol in
software. By, for example, using generic UART peripheral.</p>
<p>Lastly, we need to let the <code>drone</code> CLI utility to know about the chip. There
should be at least one debugger and at least one logger options for the
chip. This will be covered in the next section.</p>
<h1 id="drone-cli"><a class="header" href="#drone-cli">Drone CLI</a></h1>
<p>In terms of chip support, Drone CLI is responsible for the following:</p>
<ol>
<li>
<p>Generating a correct scaffold for a new project. The generated program should
be ready to flash into the chip. The program should print <code>&quot;Hello, world!&quot;</code>
string to the standard output.</p>
</li>
<li>
<p>Generating a correct linker script.</p>
</li>
<li>
<p>Working with the chip through one or more debug probes.</p>
</li>
<li>
<p>At least one method of capturing Drone logger output.</p>
</li>
</ol>
<p>All platform-specific crates should be registered at <code>drone/src/crates.rs</code>. This
includes platform crates (e.g. <code>drone-cortexm</code>), vendor-specific mappings
(e.g. <code>drone-stm32-map</code>, <code>drone-nrf-map</code>), and DSO (Drone Serial Output )
implementation crates (e.g. <code>drone-nrf91-dso</code>.)</p>
<p>Specific microcontroller models should be registered at
<code>drone/src/devices/registry.rs</code>. For example here is an entry for Nordic
Semiconductor nRF9160:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Device {
        name: &quot;nrf9160&quot;, // device identifier
        target: &quot;thumbv8m.main-none-eabihf&quot;, // Rust target triple
        flash_origin: 0x0000_0000, // Starting address of Flash memory
        ram_origin: 0x2000_0000, // Starting address of RAM
        // A link to the platform crate with specific flags and features
        platform_crate: PlatformCrate {
            krate: crates::Platform::Cortexm,
            flag: &quot;cortexm33f_r0p2&quot;,
            features: &amp;[
                &quot;floating-point-unit&quot;,
                &quot;memory-protection-unit&quot;,
                &quot;security-extension&quot;,
            ],
        },
        // A link to the bindings crate with specific flags and features
        bindings_crate: BindingsCrate {
            krate: crates::Bindings::Nrf,
            flag: &quot;nrf9160&quot;,
            features: &amp;[&quot;uarte&quot;],
        },
        probe_bmp: None, // BMP is unsupported
        probe_openocd: None, // OpenOCD is unsupported
        probe_jlink: Some(ProbeJlink { device: &quot;NRF9160&quot; }), // J-Link configuration
        log_swo: None, // SWO is unsupported
        // A link to the DSO implementation
        log_dso: Some(LogDso { krate: crates::Dso::Nrf91, features: &amp;[] }),
    },
<span class="boring">}
</span></code></pre></pre>
<p><code>drone</code> CLI provides a unified interface to various debug probes. There are
currently three supported types of debug probes: Black Magic Probe, J-Link, and
OpenOCD, which is itself an interface to different debuggers. In order to add a
new chip support to Drone, the CLI utility should be taught how to use the chip
through one of the currently known probes, or a completely new probe support can
be added for this chip.</p>
<p>The CLI utility is also responsible for capturing data from built-in Drone
logger. There are currently two protocol parsers implemented: SWO (ARM's Serial
Wire Output) and DSO (Drone Serial Output.) DSO protocol is used when there is
no hardware protocol implemented on the chip. The log output can be captured
through probe's built-in reader, or through generic external UART reader. At
least one log method should be implemented for a new chip.</p>
<h1 id="platform-specific-layer"><a class="header" href="#platform-specific-layer">Platform-Specific Layer</a></h1>
<p>This layer fills the gap between the platform-agnostic core and the specific
platform. Target-specific intrinsics and inline assembler can be used here.</p>
<p>The platform crate implements <code>drone-core</code> runtime at <code>src/rt.rs</code>. Furthermore
it can export various utility functions. For example
<code>drone_cortexm::processor::self_reset</code>, which runs a sequence of assembly
instructions to issue a self-reset request.</p>
<p>This layer provides a backend for Drone's threading API. If we take Cortex-M as
an example, here the Drone threading system is implemented by leveraging NVIC
(Nested Vectored Interrupt Controller.) Where each Drone thread corresponds to a
hardware interrupt, and NVIC is responsible for switching between the threads.</p>
<p>The crate should include at least one <code>core::task::Waker</code> implementation for
Rust <code>Future</code>s. <code>drone-cortexm</code> implements two: one for the lowest thread, which
utilizes <code>WFE</code>/<code>SEV</code> assembly instructions, and the other uses the <code>NVIC_STIR</code>
register.</p>
<p>As stackful threading is highly target-specific, stackful Drone fibers are
implemented at this layer. If the target incorporates an MPU (Memory Protection
Unit), it should be used to protect from stack overflow errors. Because the core
Drone provides zero-cost protection only for the main stack, and hence only for
stackless fibers. If there is no MPU, the corresponding constructor functions
must be marked <code>unsafe</code>.</p>
<h1 id="vendor-specific-layer"><a class="header" href="#vendor-specific-layer">Vendor-Specific Layer</a></h1>
<p>This layer consists of memory-mapped register, interrupt, and peripheral
mappings, and also possibly of DSO (Drone Serial Output) implementations. In
this section we will overview <code>drone-nrf-map</code> and <code>drone-nrf91-dso</code> crates as
examples of the vendor-specific layer.</p>
<h2 id="bindings"><a class="header" href="#bindings">Bindings</a></h2>
<p><code>drone-nrf-map</code> collection of crates is purely declarative. We try to
automatically generate as much code as possible from vendor-provided CMSIS-SVD
files. Generation of memory-mapped register bindings is highly
parallelizable. Therefore it's splitted into 12 crates, which are named from
<code>drone-nrf-map-pieces-1</code> to <code>drone-nrf-map-pieces-12</code> and compiled by cargo in
parallel. <code>drone-nrf-map-pieces-*</code> crates are all re-exported by single
<code>drone-nrf-map-pieces</code> crate, which can be further used by peripheral bindings.</p>
<p>Not all bindings can be auto-generated. We also manually declare <a href="extensibility/../periph.html">peripheral
mappings</a>. For the sake of compile-time parallelization, each
peripheral type is declared in its own crate
(e.g. <code>drone-nrf-map-periph-uarte</code>.) Periheral crates are opt-in, they are
enabled by activating corresponding cargo features for <code>drone-nrf-map</code> crate.</p>
<p>Finally, <code>drone-nrf-map-pieces</code> and <code>drone-nrf-map-periph-*</code> crates are all
re-exported by <code>drone-nrf-map</code> crate.</p>
<h2 id="drone-serial-output"><a class="header" href="#drone-serial-output">Drone Serial Output</a></h2>
<p>If the target doesn't implement usual hardware logging, as in case with nRF9160,
we provide a software logging implementation. It uses special Drone Serial
Output protocol to provide features similar to hardware SWO. Namely splitting
the output into different ports and forming atomic packets.</p>
<p><code>drone-nrf91-dso</code> implementation is based on software output FIFO, and utilizes
one of generic built-in UART peripheral.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-148590307-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
