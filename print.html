<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Drone Embedded Operating System</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="hardware.html"><strong aria-hidden="true">1.1.</strong> Hardware</a></li><li><a href="bmp-from-bluepill.html"><strong aria-hidden="true">1.2.</strong> BMP from a Blue Pill</a></li><li><a href="hello-world.html"><strong aria-hidden="true">1.3.</strong> Hello, world!</a></li></ol></li><li><a href="bluepill-blink.html"><strong aria-hidden="true">2.</strong> Blink an LED</a></li><li><ol class="section"><li><a href="bluepill-blink/full-speed.html"><strong aria-hidden="true">2.1.</strong> Run at Full Speed</a></li><li><a href="bluepill-blink/sys-tick.html"><strong aria-hidden="true">2.2.</strong> Work with a Timer</a></li></ol></li><li><a href="concurrency.html"><strong aria-hidden="true">3.</strong> Concurrency</a></li><li><ol class="section"><li><a href="fibers.html"><strong aria-hidden="true">3.1.</strong> Fibers</a></li><li><a href="processes.html"><strong aria-hidden="true">3.2.</strong> Processes</a></li><li><a href="threads.html"><strong aria-hidden="true">3.3.</strong> Threads</a></li><li><a href="tasks.html"><strong aria-hidden="true">3.4.</strong> Tasks</a></li><li><a href="message-passing.html"><strong aria-hidden="true">3.5.</strong> Message-Passing</a></li></ol></li><li><a href="heap.html"><strong aria-hidden="true">4.</strong> Dynamic Memory</a></li><li><ol class="section"><li><a href="heaptrace.html"><strong aria-hidden="true">4.1.</strong> Heap Tracing</a></li></ol></li><li><a href="testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Drone Embedded Operating System</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Drone is an Embedded Operating System for writing real-time applications in
Rust. It aims to bring modern development approaches without compromising
performance into the world of embedded programming.</p>
<h2><a class="header" href="#supported-hardware" id="supported-hardware">Supported hardware</a></h2>
<p>Drone core is platform-agnostic from the beginning. However currently only ARM®
Cortex®-M3/M4 is supported.</p>
<p>Drone also have special support for <a href="http://black-magic.org/">Black Magic Probe</a>
in form of <code>drone bmp</code> commands. But it doesn't restrict you from using any
other debug probes.</p>
<h2><a class="header" href="#design-principles" id="design-principles">Design principles</a></h2>
<ul>
<li>
<p><em>Energy effective from the start</em>. Drone encourages interrupt-driven execution
model.</p>
</li>
<li>
<p><em>Hard Real-Time</em>. Drone relies on atomic operations instead of using critical
sections.</p>
</li>
<li>
<p><em>Fully preemptive multi-tasking with strict priorities</em>. A higher priority
task takes precedence with minimal latency.</p>
</li>
<li>
<p><em>Highly concurrent.</em> Multi-tasking in Drone is very cheap, and Rust ensures it
is also safe.</p>
</li>
<li>
<p><em>Message passing concurrency</em>. Drone ships with synchronization primitives out
of the box.</p>
</li>
<li>
<p><em>Single stack by default</em>. Drone concurrency primitives are essentially
stack-less state machines. But <em>stackful tasks are still supported</em>.</p>
</li>
<li>
<p><em>Dynamic memory enabled</em>. Drone lets you use convenient data structures like
mutable strings or vectors while still staying deterministic and code
efficient.</p>
</li>
</ul>
<h2><a class="header" href="#why-use-drone" id="why-use-drone">Why use Drone?</a></h2>
<ul>
<li>
<p>Async/await by default. Drone provides all required run-time to use native
async/await syntax and execute <code>Future</code>s.</p>
</li>
<li>
<p>Doesn't require <code>unsafe</code> code. In spite of the fact that Drone core inevitably
relies on <code>unsafe</code> code, Drone applications can fully rely on the safe
abstractions provided by Drone.</p>
</li>
<li>
<p>Modern tooling. Apart from standard Rust tools like <code>cargo</code> package manager,
<code>rustfmt</code> code formatter, <code>clippy</code> code linter, Drone provides <code>drone</code>
command-line utility which can generate a new Drone project for your hardware,
or manage your debug probe.</p>
</li>
<li>
<p>Primary stack is stack-overflow protected regardless of MMU/MPU presence. But
secondary stackful tasks require MMU/MPU to ensure the safety.</p>
</li>
<li>
<p>Debug communication channels. Rust's <code>print!</code>, <code>eprint!</code> and similar macros
are mapped to Cortex-M's ITM channels 0 and 1 out of the box. Debug messages
incur no overhead when no debug probe is connected.</p>
</li>
<li>
<p><code>Drone.toml</code> configuration file, which saves you from manually writing linker
scripts.</p>
</li>
<li>
<p>Rich and safe zero-cost abstractions for memory-mapped registers. Drone
automatically generates register bindings from vendor-provided SVD files. It
also provides a way to write code generic over similar peripherals.</p>
</li>
</ul>
<h2><a class="header" href="#what-drone-doesnt" id="what-drone-doesnt">What Drone doesn't</a></h2>
<ul>
<li>
<p>Drone doesn't support loading dynamic applications. It is a library OS and is
linked statically with its application.</p>
</li>
<li>
<p>Drone doesn't implement time-slicing. It has a different execution model, but
optional time-slicing may be added in the future.</p>
</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>Unlike many other programming fields, software development for embedded systems
requires special hardware. Bare minimum is a target device, for which the
software is developed, and a debug probe that is responsible for programming and
debugging the device. Often for a particular MCU, the vendor offers a
development board, which incorporates an MCU, a debug probe, and some
peripherals. But when the development reaches a PCB prototyping stage, an
external probe is desirable. There are various debug probes in the market. A
Chinese clone can cost a couple of dollars, while original probes often cost
hundreds. But there is one unique option that is supported by Drone
out-of-the-box - <a href="http://black-magic.org/">Black Magic Probe</a>.</p>
<p>Black Magic Probe, or BMP, is an open-source tool, like Rust or Drone, which is
invaluable when it comes to troubleshooting. Currently it supports Cortex-M and
Cortex-A targets. BMP implements the GDB protocol directly, which is nice,
because there is no need for intermediate software like OpenOCD. Also it embeds
a USB-to-UART converter. The official hardware is sold around $60 and is quite
good. But the firmware supports other hardware options. The most affordable of
which is the <a href="https://web.archive.org/web/20190524151648/wiki.stm32duino.com/index.php?title=Blue_Pill">Blue
Pill</a>.</p>
<p>Blue Pill is an ultra-popular and cheap development board for STM32F103C8T6
microcontroller. It can be bought for around $1.50 from AliExpress and also can
be programmed with Drone. It has 32-bit Cortex-M3 core running at 72 Mhz max, 20
Kb of RAM, and <a href="https://web.archive.org/web/20190524151648/wiki.stm32duino.com/index.php?title=Blue_Pill#128_KB_flash_on_C8_version">128
Kb</a>
of flash memory. This is good for many applications and is enough to get started
with Drone. So the most affordable start would be with two Blue Pill boards, one
as a debug probe and the other as the host for Drone projects.</p>
<p>But there is another tool needed to flash the BMP firmware to a Blue Pill - a
USB-to-UART adapter. Out of the box a Blue Pill is flashed with a factory boot
loader, which allows programming its flash memory through UART. The cheapest
adapter would be enough for this. CH340G can be bought for around $0.50 from
AliExpress. It will not be needed after initial bootstrap of BMP, because it has
its own USB-to-UART. Though it is convenient to have a spare adapter, as
sometimes there can be multiple UARTs involved.</p>
<h1><a class="header" href="#hardware" id="hardware">Hardware</a></h1>
<p>To make a start with Drone the most affordable, the following reference hardware
was selected for this book:</p>
<p><img src="./assets/packed.jpg" alt="Packed" /></p>
<ul>
<li>2× STM32F103C8T6 development boards (Blue Pills)</li>
<li>CH340G USB-TTL converter</li>
<li>Female-to-female jumper wires</li>
</ul>
<p>And optionally:</p>
<ul>
<li>2× Angled 40-pins 2.54 mm header - Blue Pills already come with straight pin headers</li>
</ul>
<p><img src="./assets/unpacked.jpg" alt="Unpacked" /></p>
<p>Usually Blue Pills come with not soldered pin-headers, except the SWD header. If
you don't want to solder, you can twist the wires like this:</p>
<p><img src="./assets/twisted.jpg" alt="Twisted joints" /></p>
<p>Here are the Blue Pills soldered with the angled pin-headers:</p>
<p><img src="./assets/soldered.jpg" alt="Soldered pin-headers" /></p>
<p>In the next chapter we will show how to convert one of the Blue Pills to a Black
Magic Proble.</p>
<h1><a class="header" href="#black-magic-probe-from-a-blue-pill" id="black-magic-probe-from-a-blue-pill">Black Magic Probe from a Blue Pill</a></h1>
<p>This chapter describes the process of making a Black Magic Probe from a Blue
Pill board. The steps were tested on Ubuntu 18.04.3 LTS.</p>
<h2><a class="header" href="#preparation" id="preparation">Preparation</a></h2>
<p>The process requires the following packages to be installed:</p>
<pre><code class="language-shell">$ sudo apt install build-essential \
                   curl \
                   dfu-util \
                   gcc-arm-none-eabi \
                   gdb-multiarch \
                   git \
                   python \
                   python-pip
</code></pre>
<p>It is convenient to join the <code>dialout</code> group. This way you will not need
super-user privileges to work with BMP and USB-to-UART adapter:</p>
<pre><code class="language-shell">$ sudo adduser $(id -un) dialout
</code></pre>
<p>In order for the group change to take effect, you will need to re-login.</p>
<p>Get the stm32loader script and install its python dependencies:</p>
<pre><code class="language-shell">$ git clone https://github.com/jsnyder/stm32loader
$ pip install pyserial
</code></pre>
<p>Get the BMP firmware:</p>
<pre><code class="language-shell">$ git clone https://github.com/blacksphere/blackmagic
$ cd blackmagic
$ git submodule update --init --recursive
</code></pre>
<p>BMP repository provides udev rules for the probe. The rules instruct udev to
symlink the GDB endpoint to <code>/dev/ttyBmpGdb</code> and the UART to
<code>/dev/ttyBmpTarg</code>. Also they allow to upgrade BMP firmware without super-user
permissions.</p>
<pre><code class="language-shell">$ sudo cp driver/99-blackmagic.rules /etc/udev/rules.d/
$ sudo udevadm control --reload-rules
</code></pre>
<h2><a class="header" href="#building" id="building">Building</a></h2>
<p>Correct probe host should be selected. In our case it's <code>swlink</code>.</p>
<pre><code class="language-shell">$ make PROBE_HOST=swlink
</code></pre>
<p><img src="./assets/blackmagic-make.png" alt="Building" /></p>
<p>This will produce two binaries we are interested in: <code>src/blackmagic_dfu.bin</code>
and <code>src/blackmagic.bin</code>. The first is a bootloader, which will be flashed with
the USB-to-UART adapter. And the second is the actual firmware, which will be
loaded through USB with help of the bootloader.</p>
<h2><a class="header" href="#flashing-bootloader" id="flashing-bootloader">Flashing Bootloader</a></h2>
<ol>
<li>
<p>Connect the USB-to-UART adapter with the Blue Pill according to this table:</p>
<table><thead><tr><th>USB-to-UART</th><th>Blue Pill</th></tr></thead><tbody>
<tr><td>GND</td><td>GND</td></tr>
<tr><td>RXD</td><td>A9</td></tr>
<tr><td>TXD</td><td>A10</td></tr>
</tbody></table>
<p><strong>Warning:</strong> Don't connect any power source now. We will power up the board
through USB at the step 5. Using USB together with 5V or 3.3 pins can damage
your board.</p>
</li>
<li>
<p>Set the jumper on the USB-to-UART adapter to the position where VCC and 3V3
are shorted. This will set the adapter's output voltage to 3.3 v. Although it
is not strictly needed, because A9 and A10 pins are five-volt-tolerant.</p>
</li>
<li>
<p>Set BOOT0 jumper on the Blue Pill to 1 to boot into the factory programmed
bootloader. The bootloader is responsible for programming the board through
UART.</p>
</li>
</ol>
<p><img src="./assets/bluepill-ch340g.jpg" alt="CH340G connected to Blue Pill" /></p>
<ol start="4">
<li>
<p>Before connecting the USB-to-UART adapter to your PC, open the system
journal:</p>
<pre><code class="language-shell">$ journalctl -f
</code></pre>
<p>Connect the USB-to-UART adapter and notice the name it is assigned:</p>
</li>
</ol>
<p><img src="./assets/ch340g-journal.png" alt="CH340G in journal" /></p>
<ol start="5">
<li>
<p>Connect a USB-cable to the Blue Pill and start the flashing process. Replace
<code>/dev/ttyUSB0</code> with your value from the previous step. If the process is not
starting, press the reset button on the Blue Pill.</p>
<pre><code class="language-shell">$ ../stm32loader/stm32loader.py -p /dev/ttyUSB0 -e -w -v src/blackmagic_dfu.bin
</code></pre>
</li>
</ol>
<p><img src="./assets/stm32loader.png" alt="Successful load" /></p>
<ol start="6">
<li>Set BOOT0 jumper on the Blue Pill back to 0.</li>
</ol>
<p><img src="./assets/bluepill-jumpers.jpg" alt="Reset Blue Pill jumpers" /></p>
<h2><a class="header" href="#flashing-firmware" id="flashing-firmware">Flashing Firmware</a></h2>
<p>Now you can disconnect the USB-to-UART adapter from the Blue Pill and your
PC. The firmware will be flashed through USB port:</p>
<pre><code class="language-shell">$ dfu-util -d 1d50:6018,:6017 -s 0x08002000:leave -D src/blackmagic.bin
</code></pre>
<p><img src="./assets/dfu-util.png" alt="Successful load" /></p>
<p>Now we will check that it works. Reconnect the Blue Pill and open a GDB session:</p>
<pre><code class="language-shell">$ gdb-multiarch
</code></pre>
<p>At the GDB prompt enter the following commands:</p>
<pre><code class="language-text">target extended-remote /dev/ttyBmpGdb
monitor version
</code></pre>
<p><img src="./assets/gdb-monitor-version.png" alt="GDB check" /></p>
<p>If your output is similar to the output above, congratulations! Now your Blue
Pill is a Black Magic Probe! Next time you need to upgrade the firmware you only
need to repeat the <code>dfu-util</code> command above.</p>
<h2><a class="header" href="#wiring" id="wiring">Wiring</a></h2>
<p>Here is a general pin-out description and an example connection with a Blue
Pill:</p>
<table><thead><tr><th>Black Magic Probe</th><th>Function</th><th>Blue Pill Target</th></tr></thead><tbody>
<tr><td>GND</td><td>GND</td><td>GND</td></tr>
<tr><td>SWCLK</td><td>JTCK/SWCLK</td><td>SWCLK</td></tr>
<tr><td>SWIO</td><td>JTMS/SWDIO</td><td>SWIO</td></tr>
<tr><td>A15</td><td>JTDI</td><td></td></tr>
<tr><td>B3</td><td>JTDO</td><td></td></tr>
<tr><td>B4</td><td>JNTRST</td><td>R</td></tr>
<tr><td>B6</td><td>UART1 TX</td><td></td></tr>
<tr><td>B7</td><td>UART1 RX</td><td>B3</td></tr>
<tr><td>A3</td><td>UART2 RX (TRACESWO)</td><td></td></tr>
</tbody></table>
<p><img src="./assets/bmp-wiring.jpg" alt="BMP wiring" /></p>
<h2><a class="header" href="#comparison-with-official-bmp" id="comparison-with-official-bmp">Comparison with Official BMP</a></h2>
<p><img src="./assets/official-bmp-comparison.jpg" alt="Blue Pill and Official BMP" /></p>
<p>There are a few advantages of the official BMP:</p>
<ul>
<li>Has a Cortex Debug connector</li>
<li>Can power the target</li>
<li>Can sense the target's voltage</li>
<li>Has more LEDs</li>
<li>Has more robust circuitry</li>
</ul>
<p>These advantages are not critical, however by buying the official hardware you
are supporting the BMP project.</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h1>
<p>In the previous chapter we created a debug probe from a Blue Pill, and attached
it to another Blue Pill board. In this chapter we will run our first Drone
program on the microcontroller.</p>
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<p>If you haven't installed Rust yet, follow the instructions from
<a href="https://rustup.rs/">rustup.rs</a>. Drone currently available only for Nightly
channel of Rust. You need to install it first:</p>
<pre><code class="language-shell">$ rustup toolchain install nightly
</code></pre>
<h2><a class="header" href="#just-command" id="just-command"><code>just</code> command</a></h2>
<p>In embedded development often there are various project-specific tasks that are
needed to run from time to time. Therefore we encourage using an excellent Rust
crate <a href="https://github.com/casey/just"><code>just</code></a>:</p>
<pre><code class="language-shell">$ cargo +stable install just
</code></pre>
<p>Just is a command runner inspired by <code>make</code>. Whenever you see a project with
<code>Justfile</code> at the root, run <code>just --list</code> to see all available
commands. Furthermore <code>drone new</code> command will generate a <code>Justfile</code> for you. It
is advisable to put <code>alias j=&quot;just&quot;</code> to your shell config, so you could just
type <code>j</code> instead of <code>just</code>.</p>
<h2><a class="header" href="#drone-command" id="drone-command"><code>drone</code> command</a></h2>
<p>The Drone OS project consists of many Rust crates. However there is a single
entry point for it - the <code>drone</code> command-line utility:</p>
<pre><code class="language-shell">$ cargo +nightly install drone
</code></pre>
<p>For now you should have all prerequisites and could follow to the next step -
generating your first Drone crate.</p>
<h2><a class="header" href="#new-project" id="new-project">New project</a></h2>
<p>Let's tell <code>drone</code> to generate a new Drone crate for us. We have to specify the
target MCU family, which is <code>stm32f103</code> for Blue Pill, the flash memory size,
the RAM size, and the project name.</p>
<pre><code class="language-shell">$ drone new --device stm32f103 --flash-size 128K --ram-size 20K hello-world
$ cd hello-world
</code></pre>
<p>The first thing to do inside the project is to install dependencies:</p>
<pre><code class="language-shell">$ just deps
</code></pre>
<p>You should also run this task after each Rust update.</p>
<p>Now we assume you have the Blue Pills connected as follows (as described in the
previous chapter):</p>
<p><img src="./assets/bmp-wiring.jpg" alt="BMP wiring" /></p>
<p>Let's flash our newly created project to the target Blue Pill. If it have to be
built first, it could take a while:</p>
<pre><code class="language-shell">$ just flash
</code></pre>
<p>A successful result looks like this:</p>
<p><img src="./assets/just-flash.png" alt="Flash success" /></p>
<p>And finally, check the ITM output from the device.</p>
<pre><code class="language-shell">$ just itm
</code></pre>
<p><img src="./assets/just-itm.png" alt="ITM output" /></p>
<p>If you see an output like above, congratulations! You have successfully set up
an environment for developing Drone projects.</p>
<h1><a class="header" href="#blink-an-led" id="blink-an-led">Blink an LED</a></h1>
<p>In this section we will write an application that will raise the system clock
frequency to 72 MHz and blink the on-board LED connected to the PC13 pin. The
application will involve using multiple threads, futures, streams, memory-mapped
registers, and peripherals.</p>
<video autoplay loop muted width="100%">
<source src="./assets/blink.webm" type="video/webm" />
<source src="./assets/blink.mp4" type="video/mp4" />
</video>
<p>The full code for this example can be found at
<a href="https://github.com/drone-os/bluepill-blink">Github</a>.</p>
<h2><a class="header" href="#generate-a-project" id="generate-a-project">Generate a project</a></h2>
<p>To begin with, let's generate a new Drone project for a Blue Pill board:</p>
<pre><code class="language-shell">$ drone new --device stm32f103 --flash-size 128K --ram-size 20K bluepill-blink
$ cd bluepill-blink
$ just deps
</code></pre>
<p>To briefly test the newly generated application, connect a Black Magic Probe to
your PC, and a Blue Pill board to the BMP as in <a href="./hello-world.html">Hello,
world!</a> chapter. Flash the firmware and check the ITM output:</p>
<pre><code class="language-shell">$ just flash
$ just itm
</code></pre>
<p>If you can see a &quot;Hello, world!&quot; message, follow to the next chapter.</p>
<h1><a class="header" href="#run-at-full-speed" id="run-at-full-speed">Run at Full Speed</a></h1>
<p>According to the datasheet, STM32F103 MCU can run at the maximum frequency of 72
MHz. But by default it runs at only 8 MHz. To achieve the full potential of the
chip, the system frequency should be raised in the run-time.</p>
<p>There are three options for the system clock source:</p>
<ul>
<li>
<p>HSI (High Speed Internal) - an RC oscillator running at constant 8 MHz and
sitting inside the MCU chip. It is the default source for the system clock
selected at the start-up.</p>
</li>
<li>
<p>HSE (High Speed External) - an optional external resonator component in the
range from 4 to 16 MHz. A Blue Pill board has a 8 MHz crystal connected to the
MCU (the component in a metal case right beside the MCU marked as Y2.)</p>
</li>
<li>
<p>PLL (Phase-Locked Loop) - a peripheral inside the MCU that can be used as a
multiplier for HSI or HSE. The maximum multiplier for HSI is 8, which can give
us 64 MHz, and for HSE - 16, which can theoretically result in 128 MHz, but
the output frequency of PLL shouldn't exceed 72 MHz.</p>
</li>
</ul>
<p>Given the above, in order to achieve 72 MHz, we should take the following steps:</p>
<ol>
<li>Start the HSE oscillator and wait for it to stabilize.</li>
<li>Start the PLL with the HSE input and the multiplier of 9. Wait for it to
stabilize.</li>
<li>Select the PLL as the source for the system clock.</li>
</ol>
<p>For a start, let's create a module for our project-level constants. Create a new
file at <code>src/consts.rs</code> with the following content:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! Project constants.

/// HSE crystal frequency.
pub const HSE_FREQ: u32 = 8_000_000;

/// PLL multiplication factor.
pub const PLL_MULT: u32 = 9;

/// System clock frequency.
pub const SYS_CLK: u32 = HSE_FREQ * PLL_MULT;
#}</code></pre></pre>
<p>And register the module in the <code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod consts;
#}</code></pre></pre>
<p>When the application will need to wait for HSE and PLL clocks stabilization, we
don't want it to be constantly checking the flags wasting CPU cycles and energy,
but rather to subscribe for an interrupt and sleep until it is triggered. We
will use the RCC interrupt for this purpose:</p>
<p><img src="bluepill-blink/../assets/vtable-rcc.png" alt="Vector Table" /></p>
<p>From the table above, which can be found in the Reference Manual, we only need
the position of the RCC interrupt. Let's put this interrupt to the application
Vector Table. For this you need to edit <code>thr::vtable!</code> macro in <code>src/thr.rs</code>. By
default it looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
thr::vtable! {
    // ... The header is skipped ...

    // --- Allocated threads ---

    /// All classes of faults.
    pub HARD_FAULT;
}
#}</code></pre></pre>
<p>There is only a HardFault handler defined. Note that according the above table,
HardFault doesn't have a position number, therefore it is referred only by its
name. We need to add a new interrupt handler at the position of 5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
thr::vtable! {
    // ... The header is skipped ...

    // --- Allocated threads ---

    /// All classes of faults.
    pub HARD_FAULT;
    /// RCC global interrupt.
    pub 5: RCC;
}
#}</code></pre></pre>
<p>Since the new handler has a numeric position, the name can be arbitrary.</p>
<p>Let's open the root task handler at <code>src/tasks/root.rs</code>. By default it looks
like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! The root task.

use crate::{thr, thr::Thrs, Regs};
use drone_cortex_m::{reg::prelude::*, thr::prelude::*};

/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs) {
    let (thr, _) = thr::init!(reg, Thrs);

    thr.hard_fault.add_once(|| panic!(&quot;Hard Fault&quot;));

    println!(&quot;Hello, world!&quot;);

    // Enter a sleep state on ISR exit.
    reg.scb_scr.sleeponexit.set_bit();
}
#}</code></pre></pre>
<p>In Drone OS the very first task with the lowest priority is called root. Its
handler is called by the program entry point at <code>src/bin.rs</code>, after finishing
unsafe initialization routines. The root handler receives an instance of <code>Regs</code>,
which is a zero-sized type, a set of tokens for all memory-mapped
registers. Only one instance of <code>Regs</code> should ever exist. That is why creating
one is unsafe and is done inside the unsafe entry point before calling the root
handler.</p>
<p>Inside the root handler the <code>reg</code> argument is supposed to be destructured into
individual register or register field tokens. To reduce verbosity individual
registers are moved from <code>reg</code> in logical groups using macros. These macros
should be placed at the beginning of the handler. An example of such macro is
<code>thr::init!</code>, which takes an ownership of registers related to threading, such
as MPU and NVIC peripherals, and returns an instance of <code>Thrs</code>. <code>Thrs</code> is
similar to <code>Regs</code>, but for thread tokens. It is a zero-sized type as well.</p>
<p>The first thing the root task actually does (apart from passing ownerships of
zero-sized types around) is adding a fiber to the HardFault thread which will
panic on trigger. Drone handles panics by writing the panic message to the ITM
port #1, issuing a self-reset request, and blocking until it's executed.</p>
<p>Let's add a new <code>async</code> function that will be responsible for raising the system
clock frequency to 72 MHz. It will need some registers from RCC and FLASH
peripherals, as well as an RCC thread token.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! The root task.

use crate::{
    consts::{PLL_MULT, SYS_CLK},
    thr,
    thr::Thrs,
    Regs,
};
use drone_core::bmp_uart_baudrate;
use drone_cortex_m::{fib, itm, reg::prelude::*, thr::prelude::*};
use drone_stm32_map::reg;

/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs) {
    let (thr, _) = thr::init!(reg, Thrs);

    thr.hard_fault.add_once(|| panic!(&quot;Hard Fault&quot;));

    raise_system_frequency(
        reg.flash_acr,
        reg.rcc_cfgr,
        reg.rcc_cir,
        reg.rcc_cr,
        thr.rcc,
    )
    .root_wait();

    println!(&quot;Hello, world!&quot;);

    // Enter a sleep state on ISR exit.
    reg.scb_scr.sleeponexit.set_bit();
}

async fn raise_system_frequency(
    flash_acr: reg::flash::Acr&lt;Srt&gt;,
    rcc_cfgr: reg::rcc::Cfgr&lt;Srt&gt;,
    rcc_cir: reg::rcc::Cir&lt;Srt&gt;,
    rcc_cr: reg::rcc::Cr&lt;Srt&gt;,
    thr_rcc: thr::Rcc,
) {
    // TODO raise the frequency to 72 MHz
}
#}</code></pre></pre>
<p>An <code>async</code> function is a syntax sugar for a function returning a <code>Future</code>. We
execute the returned future using the <code>.root_wait()</code> method. The <code>root_wait</code>
method is supposed to be used inside a thread with the lowest priority, e.g. in
the root task context, otherwise the threads that are currently preempted could
be stalled. Another option for executing futures is to use <code>exec</code> or <code>add_exec</code>
methods on thread tokens.</p>
<p>It's good to check that the program still works:</p>
<pre><code class="language-shell">$ just flash
$ just itm
</code></pre>
<p>Let's start filling the <code>raise_system_frequency</code> function. First, we need to
enable the RCC interrupt in the NVIC, and allow the RCC peripheral to trigger
the interrupt when HSE or PLL is stabilized:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    thr_rcc.enable_int();
    rcc_cir.modify(|r| r.set_hserdyie().set_pllrdyie());
#}</code></pre></pre>
<p>Then we're enabling the HSE clock and waiting until it's stabilized:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // We need to move ownership of `hserdyc` and `hserdyf` into the fiber.
    let reg::rcc::Cir {
        hserdyc, hserdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_HSERDYF is asserted.
    let hserdy = thr_rcc.add_future(fib::new_fn(move || {
        if hserdyf.read_bit() {
            hserdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    // Enable the HSE clock.
    rcc_cr.modify(|r| r.set_hseon());
    // Sleep until RCC_CIR_HSERDYF is asserted.
    hserdy.await;
#}</code></pre></pre>
<p>And similarly enable the PLL:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // We need to move ownership of `pllrdyc` and `pllrdyf` into the fiber.
    let reg::rcc::Cir {
        pllrdyc, pllrdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_PLLRDYF is asserted.
    let pllrdy = thr_rcc.add_future(fib::new_fn(move || {
        if pllrdyf.read_bit() {
            pllrdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    rcc_cfgr.modify(|r| {
        r.set_pllsrc() // HSE oscillator clock selected as PLL input clock
            .write_pllmul(PLL_MULT - 2) // output frequency = input clock × PLL_MULT
    });
    // Enable the PLL.
    rcc_cr.modify(|r| r.set_pllon());
    // Sleep until RCC_CIR_PLLRDYF is asserted.
    pllrdy.await;
#}</code></pre></pre>
<p>The flash memory settings should be tweaked for the increased frequency:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Two wait states, if 48 MHz &lt; SYS_CLK &lt;= 72 Mhz.
    flash_acr.modify(|r| r.write_latency(2));
#}</code></pre></pre>
<p>Before increasing the frequency, we should wait until the currently ongoing ITM
transmission is finished if any. And also update the SWO prescaler to maintain
the fixed baud-rate defined at the project's <code>Drone.toml</code>. Note that if a debug
probe is not connected, this will be a no-op, thus it's safe to keep this in the
release binary.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    itm::flush();
    itm::update_prescaler(SYS_CLK, bmp_uart_baudrate!());
#}</code></pre></pre>
<p>And finally switch the source for the system clock to PLL:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    rcc_cfgr.modify(|r| r.write_sw(0b10)); // PLL selected as system clock
#}</code></pre></pre>
<p>Here is the final listing of the <code>raise_system_frequency</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn raise_system_frequency(
    flash_acr: reg::flash::Acr&lt;Srt&gt;,
    rcc_cfgr: reg::rcc::Cfgr&lt;Srt&gt;,
    rcc_cir: reg::rcc::Cir&lt;Srt&gt;,
    rcc_cr: reg::rcc::Cr&lt;Srt&gt;,
    thr_rcc: thr::Rcc,
) {
    thr_rcc.enable_int();
    rcc_cir.modify(|r| r.set_hserdyie().set_pllrdyie());

    // We need to move ownership of `hserdyc` and `hserdyf` into the fiber.
    let reg::rcc::Cir {
        hserdyc, hserdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_HSERDYF is asserted.
    let hserdy = thr_rcc.add_future(fib::new_fn(move || {
        if hserdyf.read_bit() {
            hserdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    // Enable the HSE clock.
    rcc_cr.modify(|r| r.set_hseon());
    // Sleep until RCC_CIR_HSERDYF is asserted.
    hserdy.await;

    // We need to move ownership of `pllrdyc` and `pllrdyf` into the fiber.
    let reg::rcc::Cir {
        pllrdyc, pllrdyf, ..
    } = rcc_cir;
    // Attach a listener that will notify us when RCC_CIR_PLLRDYF is asserted.
    let pllrdy = thr_rcc.add_future(fib::new_fn(move || {
        if pllrdyf.read_bit() {
            pllrdyc.set_bit();
            fib::Complete(())
        } else {
            fib::Yielded(())
        }
    }));
    rcc_cfgr.modify(|r| {
        r.set_pllsrc() // HSE oscillator clock selected as PLL input clock
            .write_pllmul(PLL_MULT - 2) // output frequency = input clock × PLL_MULT
    });
    // Enable the PLL.
    rcc_cr.modify(|r| r.set_pllon());
    // Sleep until RCC_CIR_PLLRDYF is asserted.
    pllrdy.await;

    // Two wait states, if 48 MHz &lt; SYS_CLK &lt;= 72 Mhz.
    flash_acr.modify(|r| r.write_latency(2));

    itm::flush();
    itm::update_prescaler(SYS_CLK, bmp_uart_baudrate!());

    rcc_cfgr.modify(|r| r.write_sw(0b10)); // PLL selected as system clock
}
#}</code></pre></pre>
<h1><a class="header" href="#work-with-a-timer" id="work-with-a-timer">Work with a Timer</a></h1>
<p>In this chapter we will work with a timer peripheral to timely assert and
de-assert the PC13 pin, which is connected to the green LED on the Blue Pill
board. The STM32F103 MCU possesses 7 timers of 4 different kinds. We will use
the SysTick timer, which is present in all Cortex-M MCUs.</p>
<p>Drone already has a universal interface for timer peripherals in a form of
<code>drone_cortex_m::drv::timer::Timer</code> trait, as well as the SysTick driver
implementation at <code>drone_cortex_m::drv::sys_tick::SysTick</code>. However in this
walk-through we will use interrupts and memory-mapped registers directly.</p>
<p>Firstly, we need to allocate an interrupt used by the timer peripheral. Let's
refer to the Reference Manual:</p>
<p><img src="bluepill-blink/../assets/vtable-sys-tick.png" alt="Vector Table" /></p>
<p>Unlike the RCC interrupt from the previous chapter, the SysTick doesn't have a
position value. This means that we need to declare it using a precise name and
before all the positional interrupts:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
thr::vtable! {
    // ... The header is skipped ...

    // --- Allocated threads ---

    /// All classes of faults.
    pub HARD_FAULT;
    /// System tick timer.
    pub SYS_TICK;
    /// RCC global interrupt.
    pub 5: RCC;
}
#}</code></pre></pre>
<p>According to the Reference Manual, the frequency of the SysTick clock is the
system clock divided by 8. Let's add this to our constants module
<code>src/consts.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// SysTick clock frequency.
pub const SYS_TICK_FREQ: u32 = SYS_CLK / 8;
#}</code></pre></pre>
<p>Let's update our root handler:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! The root task.

use crate::{
    consts::{PLL_MULT, SYS_CLK, SYS_TICK_FREQ},
    thr,
    thr::Thrs,
    Regs,
};
use drone_core::bmp_uart_baudrate;
use drone_cortex_m::{fib, itm, reg::prelude::*, thr::prelude::*};
use drone_stm32_map::{
    periph::{
        gpio::{periph_gpio_c, GpioC, GpioPortPeriph},
        sys_tick::{periph_sys_tick, SysTickPeriph},
    },
    reg,
};
use futures::prelude::*;

/// An error returned when a receiver has missed too many ticks.
#[derive(Debug)]
pub struct TickOverflow;

/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs) {
    let (thr, _) = thr::init!(reg, Thrs);
    let gpio_c = periph_gpio_c!(reg);
    let sys_tick = periph_sys_tick!(reg);

    thr.hard_fault.add_once(|| panic!(&quot;Hard Fault&quot;));

    raise_system_frequency(
        reg.flash_acr,
        reg.rcc_cfgr,
        reg.rcc_cir,
        reg.rcc_cr,
        thr.rcc,
    )
    .root_wait();

    beacon(gpio_c, sys_tick, thr.sys_tick)
        .root_wait()
        .expect(&quot;beacon fail&quot;);

    // Enter a sleep state on ISR exit.
    reg.scb_scr.sleeponexit.set_bit();
}

// We leave this function unchanged.
async fn raise_system_frequency(...) {...}

async fn beacon(
    gpio_c: GpioPortPeriph&lt;GpioC&gt;,
    sys_tick: SysTickPeriph,
    thr_sys_tick: thr::SysTick,
) -&gt; Result&lt;(), TickOverflow&gt; {
    Ok(())
}
#}</code></pre></pre>
<p>We added an error type <code>TickOverflow</code>, which we discuss later:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct TickOverflow;
#}</code></pre></pre>
<p>At the beginning of the root handler we added two new macros, which move parts
of the <code>reg</code> struct into new peripheral structs <code>gpio_c</code> and <code>sys_tick</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let gpio_c = periph_gpio_c!(reg);
    let sys_tick = periph_sys_tick!(reg);
#}</code></pre></pre>
<p>Those structures holds all the registers associated with the corresponding
peripherals. They can be large in number, which is why we use auto-generated
macros, but they are always zero-sized, which means they don't exist in the
run-time. We pass those peripheral structures to a new <code>async</code> function named
<code>beacon</code>. This time the function returns a <code>Result</code> type, and we handle it with
a panic:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    beacon(gpio_c, sys_tick, thr.sys_tick)
        .root_wait()
        .expect(&quot;beacon fail&quot;);
#}</code></pre></pre>
<p>Let's start filling the <code>beacon</code> function. We configure the SysTick timer
peripheral to trigger the SysTick interrupt each second:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Attach a listener that will notify us on each interrupt trigger.
    let mut tick_stream = thr_sys_tick.add_stream_pulse(
        // This closure will be called when a receiver no longer can store the
        // number of ticks since the last stream poll. If this happens, a
        // `TickOverflow` error will be sent over the stream as is final value.
        || Err(TickOverflow),
        // A fiber that will be called on each interrupt trigger. It sends a
        // single tick over the stream.
        fib::new_fn(|| fib::Yielded(Some(1))),
    );
    // Clear the current value of the timer.
    sys_tick.stk_val.store(|r| r.write_current(0));
    // Set the value to load into the `stk_val` register when the counter
    // reaches 0. We set it to the count of SysTick clocks per second, so the
    // reload will be triggered at each second.
    sys_tick.stk_load.store(|r| r.write_reload(SYS_TICK_FREQ));
    sys_tick.stk_ctrl.store(|r| {
        r.set_tickint() // Counting down to 0 triggers the SysTick interrupt
            .set_enable() // Start the counter
    });
#}</code></pre></pre>
<p>Now the <code>tick_stream</code> variable holds an instance of a <code>Stream</code> type. We <code>await</code>
for each item of the stream until it ends. The <code>tick</code> variable is a number of
pulses (in our case seconds) passed since the last stream poll. If the thread is
not heavily interrupted, normally we expect it to be just <code>1</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    while let Some(tick) = tick_stream.next().await {
        for _ in 0..tick?.get() {
            println!(&quot;sec&quot;);
        }
    }
#}</code></pre></pre>
<p>Let's flash this program and view the ITM output:</p>
<pre><code class="language-shell">$ just flash
$ just itm
</code></pre>
<p>You should see the following output. A &quot;sec&quot; line will be printed infinitely
each second.</p>
<pre><code class="language-text">================================== ITM OUTPUT ==================================
sec
sec
sec
sec
sec
</code></pre>
<p>Now it's time to use the GPIO peripheral, to drive the green LED on our Blue
Pill.</p>
<p><img src="bluepill-blink/../assets/bluepill-schematics-leds.png" alt="Blue Pill Schematics" /></p>
<p>According to the Blue Pill schematic above, the current is flowing through D2
when PC13 line is low (shorted to GND), and not flowing when its high (shorted
to VCC). Let's configure the PC13 pin, place this at the beginning of the
<code>beacon</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    gpio_c.rcc_busenr_gpioen.set_bit(); // GPIO port C clock enable
    gpio_c.gpio_crh.modify(|r| {
        r.write_mode13(0b10) // Output mode, max speed 2 MHz
            .write_cnf13(0b00) // General purpose output push-pull
    });
#}</code></pre></pre>
<p>Let's speed up our timer to wake up each 125 milliseconds. Update the <code>stk_load</code>
initialization code as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Set the value to load into the `stk_val` register when the counter
    // reaches 0. We set it to the count of SysTick clocks per second divided by
    // 8, so the reload will be triggered each 125 ms.
    sys_tick
        .stk_load
        .store(|r| r.write_reload(SYS_TICK_FREQ / 8));
#}</code></pre></pre>
<p>Update the stream loop:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // A value cycling from 0 to 7. Full cycle represents a full second.
    let mut counter = 0;
    while let Some(tick) = tick_stream.next().await {
        for _ in 0..tick?.get() {
            // Each full second print a message.
            if counter == 0 {
                println!(&quot;sec&quot;);
            }
            match counter {
                // On 0's and 250's millisecond pull the pin low.
                0 | 2 =&gt; {
                    gpio_c.gpio_bsrr.br13.set_bit();
                }
                // On 125's, 375's, 500's, 625's, 750's, and 875's millisecond
                // pull the pin high.
                _ =&gt; {
                    gpio_c.gpio_bsrr.bs13.set_bit();
                }
            }
            counter = (counter + 1) % 8;
        }
    }
#}</code></pre></pre>
<p>Now flash the application to your Blue Pill board with:</p>
<pre><code class="language-shell">$ just flash
</code></pre>
<p>And you should see the following result:</p>
<video autoplay loop muted width="100%">
<source src="../assets/blink.webm" type="video/webm" />
<source src="../assets/blink.mp4" type="video/mp4" />
</video>
<p>The full code for this application can be found at
<a href="https://github.com/drone-os/bluepill-blink">Github</a>.</p>
<h1><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h1>
<p>Concurrency model is one of the most important aspects of an Embedded Operating
System. Applications for embedded micro-controllers require operating with
multiple sources of events at one time. Furthermore an embedded system should be
in a power-saving mode as often and as long as possible. Drone's goal is to make
writing highly concurrent and power-efficient applications easy and correct.</p>
<p>First, let's see how conventional Embedded Operating Systems work. They allow
you to create tasks that are running in parallel, each with its own stack:</p>
<p><img src="../assets/conventional-rtos.svg" alt="Conventional RTOS" /></p>
<p>However this is not how hardware is actually designed. In fact, processors can
only execute a single task at a time. What conventional Operating Systems
actually do, is that they are rapidly switching between tasks, to make them
<strong>appear</strong> to be running in parallel:</p>
<p><img src="../assets/conventional-rtos-slices.svg" alt="Conventional RTOS Time Sharing" /></p>
<p>That concurrency model, while having clear advantages for desktop and server
operating systems, incurs noticeable overhead for embedded real-time
systems. Also to protect from stack overflow errors it should be running on a
processor with built-in Memory Management/Protection Unit, which is not the case
for STM32F103.</p>
<p>Contrarily, modern hardware evolves in the direction of more elaborate interrupt
controllers. For example, Nested Vectored Interrupt Controller, or NVIC, which
can be found in each Cortex-M processor. It implements many hardware
optimizations to reduce scheduling costs, such as late-arriving or
tail-chaining. Drone OS utilizes such interrupt controllers to build strictly
prioritized fully preemptive scheduling:</p>
<p><img src="../assets/drone-single-stack.svg" alt="Drone Concurrency" /></p>
<p>Only a task with a higher priority can preempt another task. And a task must
completely relinquish the stack before completing or pausing to wait for an
event or a resource. This allows Drone OS to use a single stack for all program
tasks. This single stack is also protected from stack overflow errors by placing
it at the border of the RAM.</p>
<p>So how Drone achieves such stack usage for tasks? Mainly by using Rust's
async/await or generators syntax, which translate to state machines. The task
state, which needs to be saved between resumption points, is stored much more
compactly on the heap.</p>
<p>As an option Drone also implements conventional stateful tasks. Using such tasks
one can integrate an existing blocking code with a Drone application, by
allocating a separate stack. To use this feature safely, the processor must have
an MMU/MPU. Otherwise creating such task is <code>unsafe</code>, because the safety from
stack overflow couldn't be guaranteed.</p>
<h1><a class="header" href="#fibers" id="fibers">Fibers</a></h1>
<p>Fibers in Drone OS are essentially finite-state machines. On type level, a fiber
is an instance of an anonymous type, which implements the <code>Fiber</code> trait. The
trait is defined at <code>drone_core::fib</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Fiber {
    type Input;
    type Yield;
    type Return;

    fn resume(
        self: Pin&lt;&amp;mut Self&gt;,
        input: Self::Input,
    ) -&gt; FiberState&lt;Self::Yield, Self::Return&gt;;
}

pub enum FiberState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}
#}</code></pre></pre>
<p><code>Fiber</code> and <code>FiberState</code> are similar to <code>Generator</code> and <code>GeneratorState</code> from
<code>core::ops</code>, but with addition of the input parameter. Also like generators, it
is invalid to resume a fiber after completion.</p>
<p>A fiber can be created in multiple ways using <code>drone_cortex_m::fib::new_*</code>
family of constructors. For example a fiber that completes immediately upon
resumption can be created from an <code>FnOnce</code> closure:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use core::pin::Pin;
use drone_cortex_m::{
    fib,
    fib::{Fiber, FiberState},
};

let mut fiber = fib::new_once(|| 4);
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(4));
#}</code></pre></pre>
<p>A fiber that involves multiple yield points before completion can be created
from an <code>FnMut</code> closure:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut state = 0;
let mut fiber = fib::new_fn(move || {
    if state &lt; 3 {
        state += 1;
        fib::Yielded(state)
    } else {
        fib::Complete(state)
    }
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
#}</code></pre></pre>
<p>Or an equivalent fiber can be created using Rust's generator syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut fiber = fib::new(|| {
    let mut state = 0;
    while state &lt; 3 {
        state += 1;
        yield state;
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
#}</code></pre></pre>
<p>The fibers described in this chapter are the main building blocks for Drone OS
tasks. But there is one more type of fibers, which will be described in the next
chapter.</p>
<h1><a class="header" href="#processes" id="processes">Processes</a></h1>
<p>Processes in Drone OS are special kind of fibers, that can be suspended with a
special blocking call. They use dedicated dynamically allocated stacks. On
Cortex-M platform, Drone implements processes using <code>SVC</code> assembly instruction
and SVCall exception. So before using processes, a Drone supervisor should be
added to the project.</p>
<h2><a class="header" href="#supervisor" id="supervisor">Supervisor</a></h2>
<p>Create a new file at <code>src/sv.rs</code> with the following content:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! The supervisor.

use drone_cortex_m::{
    sv,
    sv::{SwitchBackService, SwitchContextService},
};

sv! {
    /// The supervisor type.
    pub struct Sv;

    /// The array of services.
    static SERVICES;

    SwitchContextService;
    SwitchBackService;
}
#}</code></pre></pre>
<p>And register the newly created module in the <code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod sv;
#}</code></pre></pre>
<p>Update <code>thr::vtable!</code> macro inside <code>src/thr.rs</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use crate::sv::Sv;

thr::vtable! {
    use Thr;
    use Sv; // &lt;-- register the supervisor type

    // ... The types definitions are skipped ...

    // --- Allocated threads ---

    /// All classes of faults.
    pub HARD_FAULT;
    /// System service call.
    fn SV_CALL; // &lt;-- add a new external interrupt handler
}
#}</code></pre></pre>
<p>And also you will need to update your <code>src/bin.rs</code> to attach an external handler
for SVCall:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use drone_cortex_m::sv::sv_handler;
use CRATE_NAME::sv::Sv;

/// The vector table.
#[no_mangle]
pub static VTABLE: Vtable = Vtable::new(Handlers {
    reset,
    sv_call: sv_handler::&lt;Sv&gt;,
});
#}</code></pre></pre>
<h2><a class="header" href="#using-processes" id="using-processes">Using processes</a></h2>
<p>First, let's recall the generator fiber example from the previous chapter:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use core::pin::Pin;
use drone_cortex_m::{
    fib,
    fib::{Fiber, FiberState},
};

let mut fiber = fib::new(|| {
    let mut state = 0;
    while state &lt; 3 {
        state += 1;
        yield state;
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
#}</code></pre></pre>
<p>This fiber can be rewritten using Drone process as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use crate::sv::Sv;
use core::pin::Pin;
use drone_cortex_m::{
    fib,
    fib::{Fiber, FiberState},
};

let mut fiber = fib::new_proc::&lt;Sv, _, _, _, _&gt;(128, |_, yielder| {
    let mut state = 0;
    while state &lt; 3 {
        state += 1;
        yielder.proc_yield(state);
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(2));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(()), FiberState::Complete(3));
#}</code></pre></pre>
<p>The difference is that the code inside the closure argument is fully
synchronous. The <code>proc_yield</code> call is translated to the <code>SVC</code> assembly
instruction. This instruction immediately switches the execution context back to
the caller. When the <code>resume</code> method of the process is called, it continues from
the last yield point, just like a generator.</p>
<p>The <code>fib::new_proc</code> function takes a stack size as the first argument. The stack
will be immediately allocated from the heap. To make this function safe, the
processor's MPU used to protect the stack from a possible overflow. On
processors without MPU, like STM32F103, this function will panic. However it is
still possible to use processes on such systems, though without any guarantees
about stack overflows. You can use <code>new_proc_unchecked</code> function, which is
marked <code>unsafe</code>.</p>
<p>Unlike generators, a process can take input data. And unlike <code>yield</code> keyword,
the <code>proc_yield</code> function not necessarily returns <code>()</code>. Here is an example of
such process:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut fiber = fib::new_proc::&lt;Sv, _, _, _, _&gt;(128, |input, yielder| {
    let mut state = input;
    while state &lt; 4 {
        state += yielder.proc_yield(state);
    }
    state
});
assert_eq!(Pin::new(&amp;mut fiber).resume(1), FiberState::Yielded(1));
assert_eq!(Pin::new(&amp;mut fiber).resume(2), FiberState::Yielded(3));
assert_eq!(Pin::new(&amp;mut fiber).resume(3), FiberState::Complete(6));
#}</code></pre></pre>
<h1><a class="header" href="#threads" id="threads">Threads</a></h1>
<p>A thread in Drone OS corresponds to a hardware interrupt. It is a sequence of
fibers that managed independently by an interrupt controller. Threads can not be
created on demand, but should be pre-defined for a particular project. Then any
number of fibers can be attached dynamically to a particular thread.</p>
<p>Threads should be defined at <code>src/thr.rs</code> using <code>thr!</code> and <code>thr::vtable!</code>
macros:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
thr::vtable! {
    use Thr;

    /// The vector table type.
    pub struct Vtable;

    /// Explicit vector table handlers.
    pub struct Handlers;

    /// A set of thread tokens.
    pub struct Thrs;

    /// The array of thread data.
    static THREADS;

    // --- Allocated threads ---

    /// All classes of faults.
    pub HARD_FAULT;
    /// A thread for my task.
    pub 10: MY_THREAD;
}

thr! {
    use THREADS;

    /// The thread data.
    pub struct Thr {}

    /// The thread-local storage.
    pub struct ThrLocal {}
}
#}</code></pre></pre>
<p>The macros will define <code>THREADS</code> static array of <code>Thr</code> objects. In this example
the array will contain three element: <code>HARD_FAULT</code>, <code>MY_THREAD</code>, and the
implicit <code>RESET</code> thread data. <code>Thrs</code> structure is also created here, which is a
zero-sized type, a set of tokens, through which one can manipulate the
threads. This set of token can be instantiated only once, usually at the very
beginning of the root task:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// The root task handler.
#[inline(never)]
pub fn handler(reg: Regs) {
    let (thr, _) = thr::init!(reg, Thrs);

    // ... The rest of the handler ...
}
#}</code></pre></pre>
<p>Here the <code>thr</code> variable contains tokens for all defined threads. If you have
added fields to the <code>Thr</code> definition, they are accessible through
<code>thr.my_thread.to_thr()</code>. <code>ThrLocal</code> is also stored inside <code>Thr</code>, but accessible
only through the <code>thr::local()</code> free-standing function.</p>
<p>A thread can be called programmatically using implicit <code>core::task::Waker</code> or
explicit <code>thr.my_thread.trigger()</code> or directly by hardware peripherals. If the
thread, which was triggered, has a higher priority than the currently active
thread, the active thread will be preempted. If the thread has a lower priority,
it will run after all higher priority threads. Priorities can be changed on the
fly with <code>thr.my_thread.set_priority(...)</code> method.</p>
<h2><a class="header" href="#fiber-chain" id="fiber-chain">Fiber chain</a></h2>
<p>The main thing a thread owns is a fiber chain. A fiber chain is essentially a
linked list of fibers. A fiber can be added to a thread chain dynamically using
<code>thr.my_thread.add_fib(...)</code>, or other methods based on it. The <code>add_fib</code> method
is atomic, i.e. fibers can be added to a particular thread from other threads.</p>
<p>When a thread is triggered, it runs the fibers in its fiber chain one-by-one in
LIFO order. In other words the most recently added fiber will be executed
first. A fiber can return <code>fib::Yielded</code> result, which means the fiber is paused
but not completed; the thread will keep the fiber in place for the later run and
proceed with the next fiber in the chain. Or the fiber can return
<code>fib::Complete</code>, in which case the thread removes the fiber from the chain, runs
its <code>drop</code> destructor, and proceeds to the next fiber in the chain.</p>
<h1><a class="header" href="#tasks" id="tasks">Tasks</a></h1>
<p>In Drone OS applications, a task is a logical unit of work. Most often it's
represented as an <code>async</code> function that's running in a separate thread. By
convention, each task is placed into a separate module inside <code>src/tasks</code>
directory. The module contains at least a task main function named
<code>handler</code>. The function then re-exported in <code>src/tasks/mod.rs</code> like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod my_task;

pub use self::my_task::handler as my_task;
#}</code></pre></pre>
<p>It is common to use an unused interrupt as the task thread. For example, in
STM32F103, there is &quot;UART5 global interrupt&quot; at the position 53. If UART5
peripheral is not used by the application, its interrupt can be reused for a
completely different task:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
thr::vtable! {
    // ... The header is skipped ...

    // --- Allocated threads ---

    /// All classes of faults.
    pub HARD_FAULT;
    /// A thread for `my_task`.
    pub 53: MY_TASK;
}
#}</code></pre></pre>
<p>Then, assuming <code>my_task</code> is an <code>async</code> function, the thread can run the task as
follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use crate::tasks;
use drone_cortex_m::thr::prelude::*;

thr.my_task.enable_int();
thr.my_task.set_priority(0xB0);
thr.my_task.exec(tasks::my_task());
#}</code></pre></pre>
<p>Now, whenever <code>my_task</code> future or any of its nested futures returns
<code>Poll::Pending</code>, the thread suspends. And it will be resumed when the future
will be ready for polling again. It is implemented by passing a
<code>core::task::Waker</code> behind the scenes, which will trigger the thread when
<code>wake</code>d.</p>
<h1><a class="header" href="#message-passing" id="message-passing">Message-Passing</a></h1>
<p>The preferred way for inter-thread communication in Drone OS is
message-passing. In a similar way as Rust's stdlib offers <code>std::sync::mpsc</code> for
multi-producer single-consumer queues, Drone offers three different kinds of
single-producer single-consumer queues under <code>drone_core::sync::spsc</code>.</p>
<h2><a class="header" href="#oneshot" id="oneshot">Oneshot</a></h2>
<p>The oneshot channel is used to transfer an ownership of a single value from one
thread to another. You can create a channel like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use drone_core::sync::spsc::oneshot;

let (tx, rx) = oneshot::channel();
#}</code></pre></pre>
<p><code>tx</code> and <code>rx</code> are transmitting and receiving parts respectively, they can be
passed to different threads. The <code>tx</code> part has a <code>send</code> method, which takes
<code>self</code> by value, meaning it can be called only once:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tx.send(my_message);
#}</code></pre></pre>
<p>The <code>rx</code> part is a future, which means it can be <code>.await</code>ed:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let my_message = rx.await;
#}</code></pre></pre>
<h2><a class="header" href="#ring" id="ring">Ring</a></h2>
<p>For passing multiple values of one type, there is the ring channel. It works by
allocating a fixed-size ring-buffer:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use drone_core::sync::spsc::ring;

let (tx, rx) = ring::channel(100);
#}</code></pre></pre>
<p>Here <code>100</code> is the size of the underlying ring buffer. The <code>tx</code> part is used to
send values over the channel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tx.send(value1);
tx.send(value2);
tx.send(value3);
#}</code></pre></pre>
<p>The <code>rx</code> part is a stream:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
while let Some(value) = rx.next().await {
    // new value received
}
#}</code></pre></pre>
<h2><a class="header" href="#pulse" id="pulse">Pulse</a></h2>
<p>When you need to repeatedly notify the other thread about some event, but
without any payload, the ring channel might be an overkill. There is the pulse
channel, which is backed by an atomic counter:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use drone_core::sync::spsc::pulse;

let (tx, rx) = pulse::channel();
#}</code></pre></pre>
<p>The <code>tx</code> part has a <code>send</code> method, which takes a number to add to the underlying
counter:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tx.send(1);
tx.send(3);
tx.send(100);
#}</code></pre></pre>
<p>The <code>rx</code> part is a stream. Each successful poll of the stream clears the
underlying counter and returns the number, which was stored:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
while let Some(pulses) = rx.next().await {
    // `pulses` number of events was happened since the last poll
}
#}</code></pre></pre>
<h2><a class="header" href="#futures-and-streams" id="futures-and-streams">Futures and streams</a></h2>
<p>Thread tokens have methods that helps creating described channels for connecting
with a particular thread.</p>
<p><code>add_future</code> takes a fiber and returns a future (<code>rx</code> part of a oneshot
channel). The future will be resolved when the fiber returns <code>fib::Complete</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use drone_cortex_m::{fib, thr::prelude::*};

let pll_ready = thr.rcc.add_future(fib::new_fn(|| {
    if pll_ready_flag.read_bit() {
        fib::Complete(())
    } else {
        fib::Yielded(())
    }
}));
pll_ready.await;
#}</code></pre></pre>
<p><code>add_stream_ring</code> returns a stream (<code>rx</code> part of a ring channel), which resolves
each time the fiber returns <code>fib::Yielded(Some(...))</code> or
<code>fib::Complete(Some(...))</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use drone_cortex_m::{fib, thr::prelude::*};

let uart_bytes = thr.uart.add_stream_ring(
    100, // The ring buffer size
    || panic!(&quot;Ring buffer overflow&quot;),
    fib::new_fn(|| {
        if let Some(byte) = read_uart_byte() {
            fib::Yielded(Some(byte))
        } else {
            fib::Yielded(None)
        }
    }),
);
#}</code></pre></pre>
<p><code>add_stream_pulse</code> returns a stream (<code>rx</code> part of pulse channel), which resolves
each time the fiber returns <code>fib::Yielded(Some(number))</code> or
<code>fib::Complete(Some(number))</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use drone_cortex_m::{fib, thr::prelude::*};

let sys_tick_stream = thr.sys_tick.add_stream_pulse(
    || panic!(&quot;Counter overflow&quot;),
    fib::new_fn(|| fib::Yielded(Some(1))),
);
#}</code></pre></pre>
<h1><a class="header" href="#dynamic-memory" id="dynamic-memory">Dynamic Memory</a></h1>
<p>In order to unleash the full potential of Rust type system, Drone OS provides a
global allocator. This might seem paradoxical, but addition of some run-time
dynamism helps with compile-time checks. Consider the signature of
<code>thread::spawn</code> function from libstd:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static;
#}</code></pre></pre>
<p>This means that in <code>std</code> applications to spawn a new OS thread, one need to call
the <code>thread::spawn</code> function in the run-time, passing it a closure of type
<code>F</code>. An interesting aspect here is the <code>F: Send + 'static</code> bound. This
guarantees that the data captured by the closure is also <code>Send</code> and
<code>'static</code>. <code>'static</code> rejects references that has a narrower scope than the
entire program. And <code>Send</code> rejects thread-unsafe types. A nice thing here is
that all of these properties are checked in the compile-time. Naturally,
equivalent functions in Drone OS have similar signatures.</p>
<p>An allocator for embedded systems should meet the following conditions:</p>
<ol>
<li>
<p>Determinism. For real-time systems, it is important that allocation,
deallocation, and reallocation operations have predictable timing.</p>
</li>
<li>
<p>Small code size. For example jemalloc can add hundreds of kilobytes to the
binary size, while some supported MCUs have 64 KB of flash memory or even
less.</p>
</li>
</ol>
<p>Drone OS ships with a simple and predictable allocator, which fulfills the above
conditions. It splits the whole heap memory region into a number of fixed-sized
memory pools:</p>
<p><img src="../assets/heap-pools.svg" alt="Memory Pools" /></p>
<p>The pools are configured at the compile-time in the <code>Drone.toml</code>. For example:</p>
<pre><code class="language-toml">[heap]
size = &quot;10K&quot;
pools = [
    { block = &quot;4&quot;, capacity = 118 },
    { block = &quot;8&quot;, capacity = 148 },
    { block = &quot;20&quot;, capacity = 82 },
    { block = &quot;56&quot;, capacity = 34 },
    { block = &quot;116&quot;, capacity = 16 },
    { block = &quot;208&quot;, capacity = 8 },
    { block = &quot;336&quot;, capacity = 3 },
    { block = &quot;512&quot;, capacity = 1 },
]
</code></pre>
<p>In result, the Drone allocator achieves all its operations to be constant-time
and entirely atomic. However, a disadvantage of this approach is that in order
to use the memory efficiently, the pools need to be tuned for each particular
application. Drone provides tools to make it as easy as possible, which we will
cover in the next chapter.</p>
<p>By providing a global allocator, a Drone application can use not only the Rust's
<code>core</code> crate, but also the <code>alloc</code> crate. It enables one to use the following
Rust types: <code>String</code>, <code>Vec</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, and more.</p>
<h1><a class="header" href="#heap-tracing" id="heap-tracing">Heap Tracing</a></h1>
<p>Drone OS provide tools to fine-tune the built-in allocator for purposes of a
particular application. A newly generated Drone project has a predefined
<code>heaptrace</code> feature. It is used in the <code>heap!</code> macro inside <code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
heap! {
    /// A heap allocator generated from the `Drone.toml`.
    pub struct Heap;

    #[cfg(feature = &quot;heaptrace&quot;)] use drone_cortex_m::itm::trace_alloc;
    #[cfg(feature = &quot;heaptrace&quot;)] use drone_cortex_m::itm::trace_dealloc;
    #[cfg(feature = &quot;heaptrace&quot;)] use drone_cortex_m::itm::trace_grow_in_place;
    #[cfg(feature = &quot;heaptrace&quot;)] use drone_cortex_m::itm::trace_shrink_in_place;
}
#}</code></pre></pre>
<p>When the feature is activated, special hooks are attached to the generated heap
code, which will log the allocator operations to the ITM port #31. In order to
capture these logs, a version of the application firmware with this feature
activated needs to be flashed to the target device first:</p>
<pre><code class="language-shell">$ just features=heaptrace flash
</code></pre>
<p>Then you run a special recipe to capture the data:</p>
<pre><code class="language-shell">$ just heaptrace
</code></pre>
<p>This recipe is similar to <code>just itm</code>, with an exception that the data from the
ITM port #31 will be written to the <code>heaptrace</code> file. When you think it is
enough data collected, just stop it with Ctrl-C.</p>
<p>The <code>heaptrace</code> feature doesn't add much of additional code to the binary. But
it may slow down the execution of your program in allocation-heavy scenarios
considerably. Because it must wait until the log data is transmitted over the
ITM port. Though this run-time overhead applies only when a debug probe is
attached, and the <code>just heaptrace</code> command is listening.</p>
<p>When there is a non-empty <code>heaptrace</code> file with the collected data in the
project root, you may use the following command to analyze your heap usage:</p>
<pre><code class="language-shell">$ drone heap
</code></pre>
<p>It will print statistics of all your allocations during <code>just heaptrace</code>:</p>
<pre><code class="language-text">---------------------------------- HEAP USAGE ----------------------------------
 &lt;size&gt; &lt;max count&gt; &lt;allocations&gt;
      1           1             1
     12           3             7
     28           1             2
     32           1             1
    128           1             2
Maximum memory usage: 225 / 2.20%
</code></pre>
<p>The data in the <code>heaptrace</code> file can also be used to generate an optimized
memory pools layout:</p>
<pre><code class="language-shell">$ drone heap generate --pools 5
</code></pre>
<p>Here <code>5</code> is the maximum number of pools. Less pools lead to more fragmentation,
but faster allocations. You should get something like this:</p>
<pre><code class="language-text">------------------------------- SUGGESTED LAYOUT -------------------------------
# Fragmentation: 0 / 0.00%

[heap]
size = &quot;10K&quot;
pools = [
    { block = &quot;4&quot;, capacity = 201 },
    { block = &quot;12&quot;, capacity = 222 },
    { block = &quot;28&quot;, capacity = 115 },
    { block = &quot;32&quot;, capacity = 83 },
    { block = &quot;128&quot;, capacity = 7 },
]
</code></pre>
<p>It generated a <code>[heap]</code> section suitable to put into the <code>Drone.toml</code>.</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>Testing Embedded Systems is more difficult than testing standard
applications. There are at least two hardware platforms involved: the one that
runs the compiler, and the target system. Testing on the development machine is
much easier, but it can't test hardware-specific code. Conversely, testing
directly on the target system is much harder and requires elaborate hardware
setup.</p>
<p>Drone OS supports testing on the development machine out of the box. Drone
crates as well as all projects generated with <code>drone new</code> have a special
feature, named <code>std</code>. When you run the test recipe:</p>
<pre><code class="language-shell">$ just test
</code></pre>
<p>Your program is compiled for your development machine target (usually
<code>x86_64-unknown-linux-gnu</code>), and not for your device target
(e.g. <code>thumbv7m-none-eabi</code>). And the program is compiled with the <code>std</code> feature
enabled. This allows to run standard Rust's test runner.</p>
<p>This way you can use all standard Rust testing options: inline <code>#[test]</code>
functions, separate test files under <code>tests/</code> directory, documentation tests
(including <code>compile_fail</code> tests.) Also your tests have access to the <code>std</code>
crate.</p>
<p>Though, you should keep in mind that the pointer size in your tests and in the
release code will usually differ. This kind of tests is suitable for testing
algorithms and business logic. Hardware-specific code often will not even
compile. For this, you should use condition compilation like in this snippet
from <code>drone-cortex-m</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn wait_for_int() {
    #[cfg(feature = &quot;std&quot;)]
    return unimplemented!();
    unsafe { asm!(&quot;wfi&quot; :::: &quot;volatile&quot;) };
}
#}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-148590307-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
